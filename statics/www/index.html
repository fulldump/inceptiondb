<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>InceptionDB Console</title>
	<meta name="description"
		content="InceptionDB is an open-source in-memory document database with an intuitive console for building, indexing, and exploring JSON collections.">
	<link rel="canonical" href="https://inceptiondb.io/">
	<meta property="og:title" content="InceptionDB Console">
	<meta property="og:description"
		content="Connect to InceptionDB, manage collections, create blazing-fast indexes, and inspect documents with a beautiful web console.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://inceptiondb.io/">
	<meta property="og:site_name" content="InceptionDB">
	<meta property="og:image" content="https://inceptiondb.io/img/og-image.png">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="InceptionDB Console">
	<meta name="twitter:description"
		content="Explore lightning-fast JSON collections, indexes, and metrics with InceptionDB's modern console.">
	<meta name="twitter:image" content="https://inceptiondb.io/img/og-image.png">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
	<link rel="stylesheet" href="/lib/tailwind.min.css">
	<link rel="stylesheet" href="/theme.css">
	<link rel="icon"
		href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%230f172a'/><text x='50' y='58' font-size='52' text-anchor='middle' fill='white'>IDB</text></svg>">
	<style>
		@keyframes activity-marker-enter {
			0% {
				opacity: 0;
				transform: scale(0.6);
			}

			60% {
				opacity: 1;
				transform: scale(1.18);
			}

			100% {
				opacity: 1;
				transform: scale(1);
			}
		}

		.activity-marker {
			width: 12px;
			height: 12px;
			border-radius: 9999px;
			background-color: var(--activity-marker-color, #38bdf8);
			box-shadow: 0 0 0 2px var(--activity-marker-glow, rgba(56, 189, 248, 0.35));
			animation: activity-marker-enter 220ms cubic-bezier(0.26, 0.65, 0.39, 1);
		}

		.activity-marker-selected {
			box-shadow:
				0 0 0 2px var(--activity-marker-glow, rgba(56, 189, 248, 0.35)),
				0 0 12px var(--activity-marker-glow, rgba(56, 189, 248, 0.55));
		}

		.activity-marker--pending {
			--activity-marker-color: #38bdf8;
			--activity-marker-glow: rgba(56, 189, 248, 0.35);
		}

		.activity-marker--success {
			--activity-marker-color: #34d399;
			--activity-marker-glow: rgba(52, 211, 153, 0.35);
		}

		.activity-marker--error {
			--activity-marker-color: #f87171;
			--activity-marker-glow: rgba(248, 113, 113, 0.35);
		}

		#activity-modal::backdrop {
			background-color: rgba(15, 23, 42, 0.75);
		}
	</style>
	<script src="/lib/vue.global.prod.js"></script>
	<script defer src="https://umami.hola.cloud/script.js"
		data-website-id="c6f05611-d1d5-4f8d-9925-daa2f0d10160"></script>
</head>

<body class="theme-dark bg-slate-950 text-slate-100 min-h-screen">
	<div id="app">
		<dialog id="activity-modal" ref="activityModal" aria-labelledby="activity-modal-title"
			class="mx-auto mt-24 w-full max-w-lg rounded-2xl border border-slate-800 bg-slate-900 p-0 text-left text-slate-100 shadow-2xl">
			<div v-if="selectedActivityEntry" class="flex flex-col gap-4 p-6">
				<div class="flex items-start justify-between gap-3">
					<div class="space-y-1">
						<p id="activity-modal-title" class="text-sm font-semibold text-slate-100">{{
							selectedActivityEntry.label || 'Request details' }}</p>
						<p class="text-xs text-slate-400">
							<span class="uppercase tracking-wide text-slate-300">{{ selectedActivityEntry.method
								}}</span>
							<span class="mx-1 text-slate-600">&nbsp;</span>
							<span>{{ selectedActivityEntry.url }}</span>
							<span>&nbsp;(Status {{ selectedActivityEntry.statusCode }})</span>
						</p>
					</div>
				</div>
				<div v-if="false && activityRequestHeaders(selectedActivityEntry).length > 0" class="space-y-2">
					<p class="text-[11px] uppercase tracking-wide text-slate-500">Request headers</p>
					<ul class="space-y-1 text-xs text-slate-300">
						<li v-for="header in activityRequestHeaders(selectedActivityEntry)"
							:key="`${header.key}:${header.value}`" class="break-all">
							<span class="text-slate-400">{{ header.key }}:</span>
							{{ header.value }}
						</li>
					</ul>
				</div>
				<div v-if="false && activityRequestBody(selectedActivityEntry)" class="space-y-2">
					<p class="text-[11px] uppercase tracking-wide text-slate-500">Request body</p>
					<pre
						class="max-h-48 overflow-y-auto rounded bg-slate-900 px-3 py-2 text-xs text-slate-200 font-mono whitespace-pre-wrap break-words">{{ activityRequestBody(selectedActivityEntry) }}</pre>
				</div>
				<div v-if="activityRequestTabEntries.length > 0" class="space-y-2">
					<p v-if="false" class="text-[11px] uppercase tracking-wide text-slate-500">Request formats</p>
					<div class="overflow-hidden rounded-lg border border-slate-800 bg-slate-950/60">
						<div class="flex items-center gap-1 border-b border-slate-800 px-2 py-1">
							<button v-for="tab in activityRequestTabEntries" :key="tab.id" type="button"
								class="rounded-md px-3 py-1.5 text-xs font-medium transition"
								:class="selectedActivityRequestTab === tab.id
                                                                ? 'bg-slate-900 text-sky-300 border border-slate-700'
                                                                : 'text-slate-400 hover:text-slate-200 hover:bg-slate-900/40'" @click="selectedActivityRequestTab = tab.id">
								{{ tab.label }}
							</button>
						</div>
						<pre v-if="activeActivityRequestTabContent" style="height: 300px;"
							class="max-h-48 overflow-y-auto bg-slate-900 px-3 py-2 text-xs text-slate-200 font-mono whitespace-pre-wrap break-words">{{ activeActivityRequestTabContent }}</pre>
					</div>
				</div>
				<div class="flex flex-wrap items-center justify-between gap-2 text-xs text-slate-400">
					<span v-if="false">Started {{ formatActivityTime(selectedActivityEntry.startedAt) }}</span>
					<span v-if="selectedActivityEntry.durationMs !== null">Duration {{
						formatDuration(selectedActivityEntry.durationMs) }}</span>
				</div>
				<div class="flex flex-wrap justify-end gap-2 pt-2">
					<button type="button"
						class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
						@click="clearActivityLog" v-if="false">
						Clear log
					</button>
					<button type="button"
						class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
						@click="closeActivityModal">
						Close
					</button>
				</div>
			</div>
		</dialog>
		<div class="min-h-screen flex">
			<aside class="w-72 bg-slate-900 border-r border-slate-800 flex flex-col">
				<div class="px-6 py-5 border-b border-slate-800">
					<div class="flex items-center justify-between">
						<h1 class="text-xl font-semibold tracking-wide">InceptionDB</h1>
						<a class="text-slate-400 hover:text-slate-200" href="https://github.com/fulldump/inceptiondb"
							target="_blank" rel="noopener" aria-label="GitHub repository">
							<svg class="w-6 h-6" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
								<path fill-rule="evenodd"
									d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
									clip-rule="evenodd" />
							</svg>
						</a>
					</div>
					<div class="mt-4 rounded-lg border border-slate-800 bg-slate-950/70 p-3">
						<p class="text-xs uppercase tracking-wide text-slate-400">API status</p>
						<div class="mt-2 flex items-center justify-between gap-3">
							<span class="inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold"
								:class="connectionStatusBadgeClass">
								<span class="h-2 w-2 rounded-full" :class="connectionStatusDotClass"></span>
								{{ connectionStatusLabel }}
							</span>
							<button type="button"
								class="text-xs font-medium text-slate-300 hover:text-white transition disabled:cursor-not-allowed disabled:opacity-50"
								:disabled="connectionStatusChecking" @click="refreshConnectionStatus">
								{{ connectionStatusButtonLabel }}
							</button>
						</div>
						<p v-if="connectionStatusDescription" class="mt-2 text-xs text-slate-400">
							{{ connectionStatusDescription }}
						</p>
					</div>
					<button type="button"
						class="mt-5 w-full rounded-md border border-slate-700 px-3 py-2 text-sm font-medium text-slate-100 bg-slate-800 hover:bg-slate-700 transition"
						@click="toggleCreateForm">
						{{ createForm.open ? 'Cancel' : 'New collection' }}
					</button>
					<form v-if="createForm.open" class="mt-4 space-y-3" @submit.prevent="createCollection">
						<div>
							<label for="new-collection"
								class="block text-xs uppercase tracking-wide text-slate-400">Name</label>
							<input id="new-collection" v-model="createForm.name" type="text" required
								class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
								placeholder="customers">
						</div>
						<button type="submit"
							class="w-full rounded-md bg-sky-600 hover:bg-sky-500 px-3 py-2 text-sm font-semibold text-white transition">
							Create collection
						</button>
						<p v-if="createForm.error" class="text-sm text-rose-400">{{ createForm.error }}</p>
					</form>
				</div>
				<div class="flex-1 overflow-y-auto">
					<div v-if="collectionsLoading" class="px-6 py-4 text-sm text-slate-400">Loading collectionsâ€¦</div>
					<div v-else-if="collectionsError" class="px-6 py-4 text-sm text-rose-400">{{ collectionsError }}
					</div>
					<nav v-else class="py-2">
						<button v-for="collection in collections" :key="collection.name" type="button"
							class="w-full px-6 py-3 text-left hover:bg-slate-800 transition" :class="{
                'bg-slate-800 text-sky-300': isSelected(collection.name),
                'text-slate-200': !isSelected(collection.name)
              }" @click="selectCollection(collection.name)">
							<div class="flex items-center justify-between text-sm font-medium">
								<span class="truncate">{{ collection.name }}</span>
								<span class="text-xs text-slate-400" v-if="collection.total !== undefined">{{
									prettyTotal(collection.total) }}</span>
							</div>
							<p class="mt-1 text-xs text-slate-500" v-if="collection.indexes">{{ collection.indexes }}
								indexes</p>
						</button>
						<p v-if="collections.length === 0" class="px-6 py-4 text-sm text-slate-500">No collections
							registered yet.</p>
					</nav>
				</div>
			</aside>

			<main class="flex-1">
				<div v-if="!selectedCollection"
					class="flex h-full flex-col items-center justify-center text-center gap-3 px-6">
					<h2 class="text-2xl font-semibold text-slate-200">Welcome to InceptionDB</h2>
					<p class="text-slate-400 max-w-md">Select or create a collection in the sidebar to start querying,
						inserting, or deleting documents.</p>
				</div>

				<div v-else class="flex flex-col gap-6 p-6">
					<header class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
						<div>
							<h2 class="text-2xl font-semibold text-slate-100">Collection {{ selectedCollection.name }}
							</h2>
							<p class="text-sm text-slate-400 flex flex-wrap items-center gap-3">
								<span v-if="selectedCollection.total !== undefined">Total: {{ selectedCollection.total
									}}</span>
								<span v-if="queryStats.elapsed">Last query: {{ queryStats.elapsed }}</span>
								<span v-if="queryStats.returned">Documents listed: {{ queryStats.returned }}</span>
							</p>
						</div>
						<div class="flex flex-wrap gap-2">
							<button type="button"
								class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-sm font-medium text-slate-200 hover:bg-slate-800 transition"
								@click="runQuery">
								Run query
							</button>
							<button type="button"
								class="rounded-md border border-rose-500/40 bg-rose-600/20 px-3 py-2 text-sm font-medium text-rose-300 hover:bg-rose-600/30 transition"
								@click="dropCollection">
								Delete collection
							</button>
						</div>
					</header>

					<section class="rounded-xl border border-slate-800 bg-slate-900/60 p-5 shadow-inner space-y-4">
						<div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
							<div class="space-y-1">
								<h3 class="text-sm font-semibold text-slate-100">Quick document lookup</h3>
								<p class="text-xs text-slate-400">Find a document by ID without changing your current
									filters.</p>
							</div>
							<form class="flex flex-wrap items-center gap-2" @submit.prevent="lookupDocument">
								<label for="quick-search-id" class="sr-only">Document ID</label>
								<input id="quick-search-id" v-model="quickSearch.id" type="text" autocomplete="off"
									placeholder="doc-123"
									class="w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-500 md:w-48">
								<button type="submit"
									class="inline-flex items-center justify-center rounded-md bg-sky-600 px-3 py-2 text-sm font-semibold text-white transition hover:bg-sky-500 disabled:cursor-not-allowed disabled:opacity-60"
									:disabled="quickSearch.loading">
									{{ quickSearch.loading ? 'Searchingâ€¦' : 'Find' }}
								</button>
							</form>
						</div>
						<p v-if="quickSearch.error" class="text-sm text-rose-400">{{ quickSearch.error }}</p>
						<div v-else-if="quickSearch.result"
							class="space-y-3 rounded-lg border border-slate-800 bg-slate-950/60 p-4">
							<div class="flex flex-wrap items-start justify-between gap-3">
								<div>
									<p class="text-sm font-semibold text-slate-100">Document {{ quickSearch.result.id }}
									</p>
									<p v-if="quickSearchSourceLabel" class="text-xs text-slate-400">Source: {{
										quickSearchSourceLabel }}</p>
								</div>
								<div class="flex flex-wrap gap-2">
									<button type="button"
										class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 transition hover:bg-slate-800"
										@click="applyQuickSearchResult">
										Show in results
									</button>
								</div>
							</div>
							<pre
								class="max-h-48 overflow-y-auto rounded bg-slate-900 px-3 py-2 text-xs text-slate-200 font-mono whitespace-pre-wrap break-words">{{ quickSearchResultText }}</pre>
						</div>
						<p v-else-if="quickSearch.lastCheckedId && !quickSearch.loading" class="text-sm text-slate-400">
							No document with ID "{{ quickSearch.lastCheckedId }}" was found.
						</p>
					</section>

					<section class="grid gap-6 lg:grid-cols-[2fr_1fr]">
						<div class="space-y-6">
							<div class="rounded-xl border border-slate-800 bg-slate-900/60 p-5 shadow-inner space-y-5">
								<div>
									<label for="filter"
										class="block text-xs uppercase tracking-wide text-slate-400">Filter
										(JSON)</label>
									<textarea id="filter" v-model="filterText" rows="4"
										class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
										placeholder="{ }"></textarea>
									<p v-if="filterError" class="mt-2 text-sm text-rose-400">{{ filterError }}</p>
								</div>

								<div>
									<label class="block text-xs uppercase tracking-wide text-slate-400">Index</label>
									<select v-model="selectedIndexName"
										class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500">
										<option value="">No index (full scan)</option>
										<option v-for="index in indexes" :key="index.name" :value="index.name">
											{{ index.name }} Â· {{ index.type }}
										</option>
									</select>
								</div>

								<div v-if="activeIndex && activeIndex.type === 'map'" class="grid gap-2">
									<label class="block text-xs uppercase tracking-wide text-slate-400">Index
										value</label>
									<input type="text" v-model="mapValue"
										class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
										placeholder="Enter a unique value">
								</div>

								<div v-if="activeIndex && activeIndex.type === 'btree'" class="space-y-4">
									<div>
										<span class="block text-xs uppercase tracking-wide text-slate-400 mb-2">From
											(inclusive)</span>
										<div class="grid gap-3 md:grid-cols-2">
											<label v-for="field in activeIndex.fields" :key="'from-' + field"
												class="text-sm text-slate-300">
												<span class="block text-xs uppercase tracking-wide text-slate-500">{{
													field }}</span>
												<input type="text" v-model="rangeFrom[field]"
													class="mt-1 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500">
											</label>
										</div>
									</div>
									<div>
										<span class="block text-xs uppercase tracking-wide text-slate-400 mb-2">To
											(exclusive)</span>
										<div class="grid gap-3 md:grid-cols-2">
											<label v-for="field in activeIndex.fields" :key="'to-' + field"
												class="text-sm text-slate-300">
												<span class="block text-xs uppercase tracking-wide text-slate-500">{{
													field }}</span>
												<input type="text" v-model="rangeTo[field]"
													class="mt-1 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500">
											</label>
										</div>
									</div>
									<label class="inline-flex items-center gap-2 text-sm text-slate-300">
										<input type="checkbox" v-model="reverse"
											class="h-4 w-4 rounded border-slate-700 bg-slate-900">
										Reverse order
									</label>
								</div>

								<div v-if="activeIndex && activeIndex.type === 'fts'" class="grid gap-2">
									<label class="block text-xs uppercase tracking-wide text-slate-400">Search
										terms</label>
									<input type="text" v-model="ftsMatch"
										class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
										placeholder="Enter words to search">
								</div>

							</div>

							<div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
								<div v-if="queryRows.length > 0" class="border-b border-slate-800 px-5 py-3">
									<div class="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
										<div>
											<p class="text-sm font-semibold text-slate-200 flex items-center gap-1">
												<span>Results</span>
												<span class="text-base text-slate-400"
													title="Switch between JSON cards and a table layout to review your documents."
													aria-label="More information about results view options">
													&nbsp;ðŸ›ˆ
												</span>
											</p>
										</div>
										<div class="flex flex-col items-stretch gap-2 text-right md:items-end">
											<div class="inline-flex overflow-hidden rounded-md border border-slate-700 self-end"
												role="group" aria-label="Select results layout">
												<button type="button"
													class="px-3 py-1.5 text-xs font-semibold transition"
													:class="resultsViewMode === 'cards' ? 'bg-slate-800 text-slate-100' : 'bg-slate-900 text-slate-400 hover:text-slate-200'"
													:aria-pressed="resultsViewMode === 'cards'"
													@click="selectResultsView('cards')">
													JSON cards
												</button>
												<button type="button"
													class="border-l border-slate-700 px-3 py-1.5 text-xs font-semibold transition"
													:class="resultsViewMode === 'table' ? 'bg-slate-800 text-slate-100' : 'bg-slate-900 text-slate-400 hover:text-slate-200'"
													:aria-pressed="resultsViewMode === 'table'"
													@click="selectResultsView('table')">
													Table view
												</button>
											</div>
											<div class="flex flex-wrap items-center justify-end gap-2">
												<button type="button"
													class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
													:disabled="exportState.running || queryRows.length === 0"
													@click="exportResults"
													title="Large exports may take time and significant browser memory. A backend endpoint that streams compressed archives would help when exporting million-document collections.">
													{{ exportState.running ? 'Exportingâ€¦' : 'Export JSONL' }}
												</button>
											</div>
											<p v-if="exportState.error" class="text-xs text-rose-400">{{
												exportState.error }}</p>
											<p v-else-if="exportState.progress" class="text-xs text-slate-400">{{
												exportState.progress }}</p>
										</div>
									</div>
								</div>
								<div class="p-5 space-y-4">
									<div v-if="queryLoading" class="text-sm text-slate-400">Running queryâ€¦</div>
									<div v-else-if="queryError" class="text-sm text-rose-400">{{ queryError }}</div>
									<div v-else-if="queryRows.length === 0" class="text-sm text-slate-400">No documents
										found.</div>
									<div v-else class="space-y-5">
										<div class="flex flex-col items-center gap-2">
											<div
												class="inline-flex items-stretch overflow-hidden rounded-md border border-slate-700 bg-slate-900 text-xs font-semibold text-slate-200">
												<button type="button"
													class="bg-slate-900 px-3 py-2 transition hover:bg-slate-800 focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-500 disabled:cursor-not-allowed disabled:opacity-60 border-r border-slate-700"
													:disabled="disablePrev" @click="prevPage">
													Previous
												</button>
												<div
													class="flex items-center gap-2 border-r border-slate-700 px-3 py-2 text-slate-300">
													<span
														class="text-[10px] uppercase tracking-wide text-slate-400">skip</span>
													<input v-model.number="skip" type="number" min="0"
														class="h-7 w-20 rounded border border-slate-700 bg-slate-950 px-2 text-xs font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
														@change="commitSkip" @keyup.enter="commitSkip">
												</div>
												<div
													class="flex items-center gap-2 border-r border-slate-700 px-3 py-2 text-slate-300">
													<span
														class="text-[10px] uppercase tracking-wide text-slate-400">limit</span>
													<input v-model.number="limit" type="number" min="0"
														class="h-7 w-20 rounded border border-slate-700 bg-slate-950 px-2 text-xs font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
														@change="commitLimit" @keyup.enter="commitLimit">
												</div>
												<button type="button"
													class="bg-slate-900 px-3 py-2 transition hover:bg-slate-800 focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-500 disabled:cursor-not-allowed disabled:opacity-60 border-l border-slate-700"
													:disabled="disableNext" @click="nextPage">
													Next
												</button>
											</div>
											<p class="text-[11px] text-slate-400">{{ pageInfo }}</p>
										</div>
										<div v-if="resultsViewMode === 'cards'" class="space-y-4">
											<div v-for="(row, idx) in queryRows" :key="idx"
												class="rounded-lg border border-slate-800 bg-slate-950 p-4">
												<div
													class="mb-3 flex flex-wrap items-start justify-between gap-3 text-xs text-slate-500">
													<div class="space-y-1">
														<p class="text-sm font-semibold text-slate-200">Document #{{
															offset + idx + 1 }}</p>
														<p v-if="documentId(row)"
															class="text-[11px] uppercase tracking-wide text-slate-500">
															ID: {{ documentId(row) }}</p>
													</div>
													<div class="flex flex-wrap items-center gap-2">
														<button v-if="canEditDocument(row) && !isEditingRow(row)"
															type="button"
															class="rounded-md border border-slate-700 bg-slate-900 px-2 py-1 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
															@click="openEditRow(row)">
															Edit
														</button>
														<button v-if="canDeleteRow(row)" type="button"
															class="rounded-md border border-rose-500/40 bg-rose-600/20 px-2 py-1 text-xs font-semibold text-rose-200 hover:bg-rose-600/30 transition"
															@click="deleteRow(row)">
															Delete
														</button>
													</div>
												</div>
												<div v-if="isEditingRow(row) && editingDocuments[documentId(row)]"
													class="mb-3 space-y-3 rounded-lg border border-slate-800/70 bg-slate-950/60 p-4">
													<label
														class="block text-xs uppercase tracking-wide text-slate-400">Edit
														document</label>
													<textarea v-model="editingDocuments[documentId(row)].draft"
														@input="onEditDraftInput(row)" rows="10"
														class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"></textarea>
													<p class="text-[11px] text-slate-500">
														Set a field to <span
															class="font-mono text-slate-300">null</span> to remove it.
													</p>
													<div class="flex justify-end gap-2">
														<button type="button"
															class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition disabled:cursor-not-allowed disabled:opacity-60"
															:disabled="editingDocuments[documentId(row)].saving"
															@click="closeEditRow(row)">
															Cancel
														</button>
														<button type="button"
															class="rounded-md bg-sky-600 px-3 py-1.5 text-xs font-semibold text-white hover:bg-sky-500 transition disabled:cursor-not-allowed disabled:opacity-60"
															:disabled="editingDocuments[documentId(row)].saving"
															@click="saveEditRow(row)">
															{{ editingDocuments[documentId(row)].saving ? 'Savingâ€¦' :
															'Save changes' }}
														</button>
													</div>
													<p v-if="editingDocuments[documentId(row)].error"
														class="text-sm text-rose-400">
														{{ editingDocuments[documentId(row)].error }}
													</p>
													<p v-else-if="editingDocuments[documentId(row)].success"
														class="text-sm text-emerald-400">
														{{ editingDocuments[documentId(row)].success }}
													</p>
												</div>
												<pre
													class="whitespace-pre-wrap break-words text-sm text-slate-200 font-mono">{{ formatDocument(row) }}</pre>
												<p v-if="!canEditDocument(row)" class="mt-3 text-xs text-slate-500">
													The document must include an "id" field to enable editing or
													deletion.
												</p>
											</div>
										</div>
										<div v-else class="space-y-4">
											<div class="overflow-x-auto">
												<table class="min-w-full divide-y divide-slate-800 text-sm">
													<thead class="bg-slate-950/40 text-slate-300">
														<tr>
															<th scope="col" class="px-4 py-2 text-left font-semibold">#
															</th>
															<th v-for="column in tableColumns" :key="column" scope="col"
																class="px-4 py-2 text-left font-semibold">
																{{ column }}
															</th>
															<th scope="col" class="px-4 py-2 text-left font-semibold">
																Actions</th>
														</tr>
													</thead>
													<tbody class="divide-y divide-slate-800 text-slate-200">
														<tr v-for="(row, idx) in queryRows" :key="idx"
															class="transition hover:bg-slate-900/70">
															<td class="px-4 py-2 align-top text-xs text-slate-400">{{
																offset + idx + 1 }}</td>
															<td v-for="column in tableColumns" :key="column"
																class="px-4 py-2 align-top">
																<span class="font-mono text-xs break-words">{{
																	formatTableValue(row, column) }}</span>
															</td>
															<td class="px-4 py-2 align-top">
																<div class="flex flex-wrap gap-2">
																	<button
																		v-if="canEditDocument(row) && !isEditingRow(row)"
																		type="button"
																		class="rounded-md border border-slate-700 bg-slate-900 px-2 py-1 text-[11px] font-semibold text-slate-200 hover:bg-slate-800 transition"
																		@click="openEditRow(row)">
																		Edit
																	</button>
																	<button
																		v-if="isEditingRow(row) && editingDocuments[documentId(row)]"
																		type="button"
																		class="rounded-md border border-slate-700 bg-slate-900 px-2 py-1 text-[11px] font-semibold text-slate-200 hover:bg-slate-800 transition"
																		@click="closeEditRow(row)">
																		Close editor
																	</button>
																	<button v-if="canDeleteRow(row)" type="button"
																		class="rounded-md border border-rose-500/40 bg-rose-600/20 px-2 py-1 text-[11px] font-semibold text-rose-200 hover:bg-rose-600/30 transition"
																		@click="deleteRow(row)">
																		Delete
																	</button>
																</div>
															</td>
														</tr>
													</tbody>
												</table>
											</div>
											<div v-for="editing in openEditingRows" :key="editing.id"
												class="space-y-3 rounded-lg border border-slate-800/70 bg-slate-950/60 p-4">
												<div class="flex flex-wrap items-center justify-between gap-2">
													<p
														class="text-xs font-semibold uppercase tracking-wide text-slate-400">
														Edit document {{ editing.id }}</p>
													<p class="text-[11px] text-slate-500">Document #{{ editing.position
														}}</p>
												</div>
												<textarea v-model="editing.state.draft"
													@input="onEditDraftInput(editing.row)" rows="10"
													class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"></textarea>
												<p class="text-[11px] text-slate-500">
													Set a field to <span class="font-mono text-slate-300">null</span> to
													remove it.
												</p>
												<div class="flex justify-end gap-2">
													<button type="button"
														class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition disabled:cursor-not-allowed disabled:opacity-60"
														:disabled="editing.state.saving"
														@click="closeEditRow(editing.row)">
														Cancel
													</button>
													<button type="button"
														class="rounded-md bg-sky-600 px-3 py-1.5 text-xs font-semibold text-white hover:bg-sky-500 transition disabled:cursor-not-allowed disabled:opacity-60"
														:disabled="editing.state.saving"
														@click="saveEditRow(editing.row)">
														{{ editing.state.saving ? 'Savingâ€¦' : 'Save changes' }}
													</button>
												</div>
												<p v-if="editing.state.error" class="text-sm text-rose-400">
													{{ editing.state.error }}
												</p>
												<p v-else-if="editing.state.success" class="text-sm text-emerald-400">
													{{ editing.state.success }}
												</p>
											</div>
										</div>
										<div class="flex flex-col items-center gap-2">
											<div
												class="inline-flex items-stretch overflow-hidden rounded-md border border-slate-700 bg-slate-900 text-xs font-semibold text-slate-200">
												<button type="button"
													class="bg-slate-900 px-3 py-2 transition hover:bg-slate-800 focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-500 disabled:cursor-not-allowed disabled:opacity-60 border-r border-slate-700"
													:disabled="disablePrev" @click="prevPage">
													Previous
												</button>
												<div
													class="flex items-center gap-2 border-r border-slate-700 px-3 py-2 text-slate-300">
													<span
														class="text-[10px] uppercase tracking-wide text-slate-400">skip</span>
													<input v-model.number="skip" type="number" min="0"
														class="h-7 w-20 rounded border border-slate-700 bg-slate-950 px-2 text-xs font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
														@change="commitSkip" @keyup.enter="commitSkip">
												</div>
												<div
													class="flex items-center gap-2 border-r border-slate-700 px-3 py-2 text-slate-300">
													<span
														class="text-[10px] uppercase tracking-wide text-slate-400">limit</span>
													<input v-model.number="limit" type="number" min="0"
														class="h-7 w-20 rounded border border-slate-700 bg-slate-950 px-2 text-xs font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
														@change="commitLimit" @keyup.enter="commitLimit">
												</div>
												<button type="button"
													class="bg-slate-900 px-3 py-2 transition hover:bg-slate-800 focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-500 disabled:cursor-not-allowed disabled:opacity-60 border-l border-slate-700"
													:disabled="disableNext" @click="nextPage">
													Next
												</button>
											</div>
											<p class="text-[11px] text-slate-400">{{ pageInfo }}</p>
										</div>
									</div>
								</div>
							</div>
						</div>

						<div class="space-y-6">
							<div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
								<button type="button"
									class="flex w-full items-center justify-between gap-3 px-5 py-4 text-left"
									@click="toggleCard('metrics')" :aria-expanded="collapsibleCards.metrics"
									aria-controls="card-content-metrics">
									<h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Collection
										metrics</h3>
									<span class="text-lg leading-none text-slate-400">
										{{ collapsibleCards.metrics ? 'âˆ’' : '+' }}
									</span>
								</button>
								<div v-if="collapsibleCards.metrics" id="card-content-metrics"
									class="space-y-4 border-t border-slate-800/80 px-5 py-4">
									<div class="flex items-start justify-between gap-3">
										<p class="text-xs text-slate-400">Estimated storage usage returned by the size
											endpoint.</p>
										<button type="button"
											class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
											:disabled="!selectedCollection || sizeMetrics.loading"
											@click="refreshSizeMetrics">
											{{ sizeMetrics.loading ? 'Refreshingâ€¦' : 'Refresh' }}
										</button>
									</div>
									<p v-if="!selectedCollection" class="text-sm text-slate-400">
										Select a collection to inspect its metrics.
									</p>
									<p v-else-if="sizeMetrics.loading" class="text-sm text-slate-400">Loading metricsâ€¦
									</p>
									<p v-else-if="sizeMetrics.error" class="text-sm text-rose-400">{{ sizeMetrics.error
										}}</p>
									<div v-else-if="sizeMetricsEntries.length > 0" class="space-y-3">
										<p v-if="sizeMetricsUpdatedLabel"
											class="text-[11px] uppercase tracking-wide text-slate-500">
											Updated at {{ sizeMetricsUpdatedLabel }}
										</p>
										<dl
											class="divide-y divide-slate-800 rounded-lg border border-slate-800/70 bg-slate-950/60">
											<div v-for="entry in sizeMetricsEntries" :key="entry.key"
												class="flex items-center justify-between gap-3 px-3 py-2 text-sm">
												<dt class="text-slate-300">{{ entry.label }}</dt>
												<dd class="font-mono text-slate-100" :title="entry.tooltip">{{
													entry.value }}</dd>
											</div>
										</dl>
									</div>
									<p v-else-if="sizeMetrics.data" class="text-sm text-slate-400">No metrics reported
										for this collection.</p>
									<p v-else class="text-sm text-slate-400">Metrics will appear after refreshing.</p>
								</div>
							</div>

							<div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
								<button type="button"
									class="flex w-full items-center justify-between gap-3 px-5 py-4 text-left"
									@click="toggleCard('defaults')" :aria-expanded="collapsibleCards.defaults"
									aria-controls="card-content-defaults">
									<h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Collection
										defaults</h3>
									<span class="text-lg leading-none text-slate-400">
										{{ collapsibleCards.defaults ? 'âˆ’' : '+' }}
									</span>
								</button>
								<div v-if="collapsibleCards.defaults" id="card-content-defaults"
									class="space-y-4 border-t border-slate-800/80 px-5 py-4">
									<div class="flex items-start justify-between gap-2">
										<p class="text-xs text-slate-400">
											Documents missing fields will receive these values when inserted.
										</p>
										<button type="button"
											class="text-base leading-none text-slate-400 transition hover:text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500/70 rounded-full"
											@click="defaultsHelpOpen = !defaultsHelpOpen"
											:aria-expanded="defaultsHelpOpen" aria-label="Toggle special values help">
											<span aria-hidden="true">ðŸ›ˆ</span>
										</button>
									</div>
									<div v-if="defaultsHelpOpen"
										class="space-y-2 rounded-lg border border-slate-800/70 bg-slate-950/60 p-3 text-[11px] text-slate-400">
										<p class="text-xs font-semibold uppercase tracking-wide text-slate-300">Special
											values</p>
										<ul class="list-disc space-y-1 pl-4">
											<li>
												<span class="font-mono text-slate-200">uuid()</span>
												Generate a unique identifier.
											</li>
											<li>
												<span class="font-mono text-slate-200">unixnano()</span>
												Insert the current timestamp in nanoseconds.
											</li>
											<li>
												<span class="font-mono text-slate-200">auto()</span>
												Assign an auto-incrementing number within the collection.
											</li>
										</ul>
									</div>
									<textarea v-model="defaultsForm.draft" rows="8"
										class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
										placeholder='{"verified": false}' :disabled="!selectedCollection"></textarea>
									<div class="flex justify-end gap-2">
										<button type="button"
											class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
											:disabled="!selectedCollection || defaultsForm.saving || defaultsForm.draft === defaultsForm.original"
											@click="resetDefaultsForm">
											Reset changes
										</button>
										<button type="button"
											class="rounded-md bg-sky-600 px-3 py-2 text-xs font-semibold text-white transition hover:bg-sky-500 disabled:cursor-not-allowed disabled:opacity-60"
											:disabled="!selectedCollection || defaultsForm.saving"
											@click="saveDefaults">
											{{ defaultsForm.saving ? 'Savingâ€¦' : 'Save defaults' }}
										</button>
									</div>
									<p v-if="defaultsForm.error" class="text-sm text-rose-400">{{ defaultsForm.error }}
									</p>
									<p v-else-if="defaultsForm.success" class="text-sm text-emerald-400">{{
										defaultsForm.success }}</p>
								</div>
							</div>

							<div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
								<button type="button"
									class="flex w-full items-center justify-between gap-3 px-5 py-4 text-left"
									@click="toggleCard('insert')" :aria-expanded="collapsibleCards.insert"
									aria-controls="card-content-insert">
									<h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Insert
										document</h3>
									<span class="text-lg leading-none text-slate-400">
										{{ collapsibleCards.insert ? 'âˆ’' : '+' }}
									</span>
								</button>
								<div v-if="collapsibleCards.insert" id="card-content-insert"
									class="space-y-4 border-t border-slate-800/80 px-5 py-4">
									<textarea v-model="insertForm.payload" rows="8"
										class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
										placeholder='{"name": "Ada"}'></textarea>
									<div class="flex justify-end">
										<button type="button"
											class="rounded-md bg-sky-600 px-4 py-2 text-sm font-semibold text-white hover:bg-sky-500 transition"
											@click="insertDocument">
											Insert
										</button>
									</div>
									<p v-if="insertForm.error" class="text-sm text-rose-400">{{ insertForm.error }}</p>
									<p v-else-if="insertForm.success" class="text-sm text-emerald-400">{{
										insertForm.success }}</p>
								</div>
							</div>

							<div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
								<button type="button"
									class="flex w-full items-center justify-between gap-3 px-5 py-4 text-left"
									@click="toggleCard('importCsv')" :aria-expanded="collapsibleCards.importCsv"
									aria-controls="card-content-import">
									<h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Import CSV
									</h3>
									<span class="text-lg leading-none text-slate-400">
										{{ collapsibleCards.importCsv ? 'âˆ’' : '+' }}
									</span>
								</button>
								<div v-if="collapsibleCards.importCsv" id="card-content-import"
									class="space-y-4 border-t border-slate-800/80 px-5 py-4">
									<p class="text-xs text-slate-400">
										Upload a CSV file to insert multiple documents at once. The first row should
										contain the field names.
									</p>
									<div class="grid gap-3 md:grid-cols-2">
										<div class="md:col-span-2">
											<label for="csv-file"
												class="block text-xs uppercase tracking-wide text-slate-400">CSV
												file</label>
											<input :key="csvImportForm.inputKey" id="csv-file" type="file"
												accept=".csv,text/csv"
												class="mt-1 block w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500 file:mr-4 file:rounded-md file:border-0 file:bg-slate-800 file:px-4 file:py-2 file:text-sm file:font-medium file:text-slate-100 hover:file:bg-slate-700"
												@change="onCsvFileChange">
										</div>
										<div>
											<label for="csv-delimiter"
												class="block text-xs uppercase tracking-wide text-slate-400">Delimiter</label>
											<select id="csv-delimiter" v-model="csvImportForm.delimiter"
												class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500">
												<option value=",">Comma (,)</option>
												<option value=";">Semicolon (;)</option>
												<option value="\t">Tab</option>
												<option value="|">Pipe (|)</option>
											</select>
										</div>
										<div>
											<label for="csv-trim"
												class="block text-xs uppercase tracking-wide text-slate-400">Trim
												whitespace</label>
											<select id="csv-trim" v-model="csvImportForm.trimValues"
												class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500">
												<option :value="true">Yes</option>
												<option :value="false">No</option>
											</select>
										</div>
									</div>
									<p v-if="csvImportForm.fileName" class="text-xs text-slate-500">Selected file: {{
										csvImportForm.fileName }}</p>
									<div class="flex justify-end gap-2">
										<button type="button"
											class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
											:disabled="csvImportForm.importing" @click="resetCsvImportForm">
											Clear
										</button>
										<button type="button"
											class="rounded-md bg-sky-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-sky-500 disabled:cursor-not-allowed disabled:opacity-60"
											:disabled="!csvImportForm.file || csvImportForm.importing"
											@click="importCsv">
											{{ csvImportForm.importing ? 'Importingâ€¦' : 'Import CSV' }}
										</button>
									</div>
									<p v-if="csvImportForm.error" class="text-sm text-rose-400">{{ csvImportForm.error
										}}</p>
									<p v-else-if="csvImportForm.success" class="text-sm text-emerald-400">{{
										csvImportForm.success }}</p>
									<p v-else-if="csvImportForm.progress" class="text-sm text-slate-400">{{
										csvImportForm.progress }}</p>
								</div>
							</div>

							<div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
								<button type="button"
									class="flex w-full items-center justify-between gap-3 px-5 py-4 text-left"
									@click="toggleCard('indexes')" :aria-expanded="collapsibleCards.indexes"
									aria-controls="card-content-indexes">
									<h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Indexes
									</h3>
									<span class="text-lg leading-none text-slate-400">
										{{ collapsibleCards.indexes ? 'âˆ’' : '+' }}
									</span>
								</button>
								<div v-if="collapsibleCards.indexes" id="card-content-indexes"
									class="space-y-4 border-t border-slate-800/80 px-5 py-4">
									<div class="flex justify-end">
										<button type="button"
											class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
											@click="toggleIndexForm">
											{{ indexForm.open ? 'Cancel' : 'New index' }}
										</button>
									</div>
									<p v-if="indexMessages.error" class="text-sm text-rose-400">{{ indexMessages.error
										}}</p>
									<p v-else-if="indexMessages.success" class="text-sm text-emerald-400">{{
										indexMessages.success }}</p>
									<form v-if="indexForm.open"
										class="space-y-3 rounded-lg border border-slate-800/70 bg-slate-950/60 p-4"
										@submit.prevent="createIndex">
										<div>
											<label for="index-name"
												class="block text-xs uppercase tracking-wide text-slate-400">Name</label>
											<input id="index-name" v-model="indexForm.name" type="text" required
												class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
												placeholder="by_email">
										</div>
										<div>
											<label for="index-type"
												class="block text-xs uppercase tracking-wide text-slate-400">Type</label>
											<select id="index-type" v-model="indexForm.type"
												class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500">
												<option value="map">Map</option>
												<option value="btree">B-Tree</option>
												<option value="fts">Full Text Search</option>
											</select>
										</div>
										<div v-if="indexForm.type === 'map' || indexForm.type === 'fts'"
											class="space-y-2">
											<div>
												<label for="index-field"
													class="block text-xs uppercase tracking-wide text-slate-400">Field</label>
												<input id="index-field" v-model="indexForm.field" type="text" required
													class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
													placeholder="email">
											</div>
											<label v-if="indexForm.type === 'map'"
												class="inline-flex items-center gap-2 text-xs text-slate-300">
												<input type="checkbox" v-model="indexForm.sparse"
													class="h-4 w-4 rounded border-slate-700 bg-slate-900">
												Sparse (ignore documents without the field)
											</label>
										</div>
										<div v-else-if="indexForm.type === 'btree'" class="space-y-2">
											<div>
												<label for="index-fields"
													class="block text-xs uppercase tracking-wide text-slate-400">Fields</label>
												<input id="index-fields" v-model="indexForm.fieldsText" type="text"
													required
													class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
													placeholder="lastName, firstName">
												<p class="mt-1 text-[11px] text-slate-500">
													Separate fields with commas. Prefix with "-" for descending order.
												</p>
											</div>
											<label class="inline-flex items-center gap-2 text-xs text-slate-300">
												<input type="checkbox" v-model="indexForm.sparse"
													class="h-4 w-4 rounded border-slate-700 bg-slate-900">
												Sparse (ignore documents missing the fields)
											</label>
											<label class="inline-flex items-center gap-2 text-xs text-slate-300">
												<input type="checkbox" v-model="indexForm.unique"
													class="h-4 w-4 rounded border-slate-700 bg-slate-900">
												Unique (reject duplicate combinations)
											</label>
										</div>
										<div class="flex justify-end gap-2">
											<button type="button"
												class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
												@click="toggleIndexForm">
												Cancel
											</button>
											<button type="submit"
												class="rounded-md bg-sky-600 px-3 py-2 text-xs font-semibold text-white hover:bg-sky-500 transition disabled:cursor-not-allowed disabled:opacity-60"
												:disabled="indexForm.submitting">
												{{ indexForm.submitting ? 'Creatingâ€¦' : 'Create index' }}
											</button>
										</div>
									</form>
									<div v-if="indexesLoading" class="text-sm text-slate-400">Loading indexesâ€¦</div>
									<div v-else-if="indexes.length === 0" class="text-sm text-slate-400">This collection
										has no indexes yet.</div>
									<ul v-else class="space-y-3 text-sm text-slate-300">
										<li v-for="index in indexes" :key="index.name"
											class="rounded-lg border border-slate-800 bg-slate-950 p-3">
											<div class="flex items-start justify-between gap-3">
												<div class="space-y-2">
													<div class="flex items-center gap-2 text-slate-200">
														<span class="font-semibold">{{ index.name }}</span>
														<span
															class="rounded-full border border-slate-700/80 bg-slate-900 px-2 py-0.5 text-[11px] uppercase tracking-wide text-slate-400">
															{{ index.type === 'btree' ? 'B-Tree' : (index.type === 'fts'
															? 'FTS' : 'Map') }}
														</span>
													</div>
													<p v-if="index.type === 'map' || index.type === 'fts'"
														class="text-xs text-slate-400">Field: {{ index.field }}</p>
													<p v-else-if="index.type === 'btree'"
														class="text-xs text-slate-400">Fields: {{
														Array.isArray(index.fields) ? index.fields.join(', ') : '' }}
													</p>
													<div
														class="flex flex-wrap gap-2 text-[11px] uppercase tracking-wide text-slate-400">
														<span v-if="index.unique"
															class="rounded bg-slate-800 px-2 py-0.5 text-emerald-300/90">Unique</span>
														<span v-if="index.sparse"
															class="rounded bg-slate-800 px-2 py-0.5 text-slate-200/80">Sparse</span>
													</div>
												</div>
												<button type="button"
													class="rounded-md border border-rose-500/40 bg-rose-600/20 px-2 py-1 text-xs font-semibold text-rose-200 hover:bg-rose-600/30 transition"
													@click="removeIndex(index)">
													Delete
												</button>
											</div>
										</li>
									</ul>
								</div>
							</div>

						</div>
					</section>
				</div>
			</main>
			<div v-if="activityLog.length > 0"
				class="pointer-events-none fixed inset-y-0 right-4 z-40 hidden w-12 flex-col items-center justify-center sm:flex"
				aria-hidden="false">
				<div class="pointer-events-auto flex max-h-[80vh] flex-col items-center gap-2 overflow-y-auto rounded-full bg-slate-950/85 px-3 py-4 shadow-2xl"
					role="list" aria-label="Recent requests">
					<button v-for="entry in activityLog" :key="entry.id" type="button"
						class="activity-marker transition-transform duration-150 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 focus:ring-offset-slate-900 hover:scale-125"
						:class="[
              activityMarkerClass(entry),
              activityDetailOpen && selectedActivityEntry && selectedActivityEntry.id === entry.id ? 'activity-marker-selected' : ''
            ]" :title="activityMarkerTitle(entry)" :aria-label="activityMarkerTitle(entry)" role="listitem"
						@click="openActivityDetail(entry)"></button>
				</div>
			</div>
		</div>

	</div>

	<script>
		const { createApp, ref, reactive, computed, watch, onMounted, onBeforeUnmount, nextTick } = Vue;

		const applyResponseTransforms = (data, transform) => {
			if (Array.isArray(transform)) {
				return transform.reduce((acc, fn) => {
					return typeof fn === 'function' ? fn(acc) : acc;
				}, data);
			}
			if (typeof transform === 'function') {
				return transform(data);
			}
			return data;
		};

		const isJsonLikePayload = (value) => {
			if (value === null || value === undefined) return false;
			if (typeof value === 'string') return false;
			if (value instanceof Blob) return false;
			if (value instanceof ArrayBuffer) return false;
			if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView && ArrayBuffer.isView(value)) return false;
			if (value instanceof FormData) return false;
			if (value instanceof URLSearchParams) return false;
			if (typeof ReadableStream !== 'undefined' && value instanceof ReadableStream) return false;
			return typeof value === 'object';
		};

		const httpRequest = async (config) => {
			const {
				url,
				method = 'GET',
				data,
				headers: inputHeaders = {},
				responseType,
				transformResponse,
			} = config || {};

			if (!url) {
				throw new Error('Request URL is required');
			}

			const headers = new Headers(inputHeaders);
			let body = data;
			if (body !== undefined && body !== null && isJsonLikePayload(body)) {
				body = JSON.stringify(body);
				if (!headers.has('Content-Type')) {
					headers.set('Content-Type', 'application/json');
				}
			}

			const fetchOptions = {
				method: String(method || 'GET').toUpperCase(),
				headers,
				body,
			};

			if (body === undefined || body === null) {
				delete fetchOptions.body;
			}

			let response;
			try {
				response = await fetch(url, fetchOptions);
			} catch (error) {
				throw error;
			}

			const rawText = await response.text();
			const expectedType = responseType || 'json';
			let parsedData;
			if (expectedType === 'text') {
				parsedData = rawText;
			} else if (!rawText) {
				parsedData = null;
			} else {
				try {
					parsedData = JSON.parse(rawText);
				} catch (err) {
					parsedData = rawText;
				}
			}

			const finalData = applyResponseTransforms(parsedData, transformResponse);

			if (!response.ok) {
				const error = new Error(`HTTP ${response.status}`);
				error.response = {
					status: response.status,
					statusText: response.statusText,
					data: finalData,
					headers: response.headers,
				};
				throw error;
			}

			return {
				status: response.status,
				statusText: response.statusText,
				data: finalData,
				headers: response.headers,
			};
		};

		const http = {
			request: (options) => httpRequest(options || {}),
			get: (url, options = {}) => httpRequest({ ...options, url, method: 'GET' }),
			post: (url, data, options = {}) => httpRequest({ ...options, url, data, method: 'POST' }),
		};

		createApp({
			setup() {
				const collections = ref([]);
				const collectionsLoading = ref(false);
				const collectionsError = ref('');
				const selectedCollectionName = ref('');
				const indexes = ref([]);
				const indexesLoading = ref(false);
				const filterText = ref('{\n\n}');
				const filterError = ref('');
				const skip = ref(0);
				const limit = ref(25);
				const appliedSkip = ref(0);
				const appliedLimit = ref(25);
				const queryRows = ref([]);
				const queryLoading = ref(false);
				const queryError = ref('');
				const queryStats = reactive({ elapsed: '', returned: 0 });
				const resultsViewMode = ref('cards');
				const selectedIndexName = ref('');
				const mapValue = ref('');
				const ftsMatch = ref('');
				const reverse = ref(false);
				const rangeFrom = reactive({});
				const rangeTo = reactive({});
				const editingDocuments = reactive({});
				const emptyJsonObjectText = '{\n\n}';
				const insertForm = reactive({ payload: emptyJsonObjectText, error: '', success: '' });
				const csvImportForm = reactive({
					file: null,
					fileName: '',
					delimiter: ',',
					trimValues: true,
					importing: false,
					error: '',
					success: '',
					progress: '',
					inputKey: 0,
				});
				const defaultsForm = reactive({
					draft: emptyJsonObjectText,
					original: emptyJsonObjectText,
					error: '',
					success: '',
					saving: false,
				});
				const defaultsHelpOpen = ref(false);
				const collapsibleCards = reactive({
					metrics: false,
					defaults: false,
					insert: false,
					importCsv: false,
					indexes: false,
				});
				const cardLoadTracker = reactive({
					metrics: {},
					indexes: {},
				});
				const createForm = reactive({ open: false, name: '', error: '' });
				const indexForm = reactive({
					open: false,
					name: '',
					type: 'map',
					field: '',
					fieldsText: '',
					sparse: false,
					unique: false,
					submitting: false,
				});
				const indexMessages = reactive({ error: '', success: '' });
				const connectionStatus = reactive({
					state: 'unknown',
					detail: 'Waiting for first response.',
					checkedAt: null,
					isChecking: false,
				});
				const MAX_ACTIVITY_LOG_ENTRIES = 15;
				const EXPORT_BATCH_SIZE = 1000;
				const MAX_EXPORT_BATCHES = 10000;
				const activityLog = ref([]);
				const activityDetailOpen = ref(false);
				const selectedActivityEntry = ref(null);
				const activityModal = ref(null);
				const modalMode = ref('welcome');
				const modalOpen = ref(false);
				const selectedActivityRequestTab = ref('http');
				const exportState = reactive({
					running: false,
					progress: '',
					error: '',
				});
				const sizeMetrics = reactive({
					loading: false,
					error: '',
					data: null,
					updatedAt: null,
				});
				const quickSearch = reactive({
					id: '',
					loading: false,
					error: '',
					result: null,
					lastCheckedId: '',
				});

				const timeFormatter = new Intl.DateTimeFormat('en-US', {
					hour: 'numeric',
					minute: '2-digit',
					second: '2-digit',
					hour12: true,
				});
				const numberFormatter = new Intl.NumberFormat('en-US');

				const resetQuickSearchState = (clearInput = false) => {
					quickSearch.loading = false;
					quickSearch.error = '';
					quickSearch.result = null;
					quickSearch.lastCheckedId = '';
					if (clearInput) {
						quickSearch.id = '';
					}
				};

				const toNonNegativeInteger = (value, fallback = 0) => {
					const num = Number(value);
					if (!Number.isFinite(num)) return fallback;
					if (Number.isNaN(num)) return fallback;
					return Math.max(0, Math.floor(num));
				};

				const DEFAULT_LIMIT = 25;

				const parseRouteHash = (hash) => {
					if (typeof hash !== 'string') {
						return { collection: '', params: {} };
					}
					const trimmed = hash.replace(/^#/, '');
					if (!trimmed) {
						return { collection: '', params: {} };
					}
					const [pathPart, searchPart = ''] = trimmed.split('?');
					const segments = pathPart.split('/').filter(Boolean);
					let collection = '';
					if (segments[0] === 'collections' && segments[1]) {
						try {
							collection = decodeURIComponent(segments[1]);
						} catch (err) {
							collection = segments[1];
						}
					}
					const params = {};
					try {
						const search = new URLSearchParams(searchPart);
						for (const [key, value] of search.entries()) {
							params[key] = value;
						}
					} catch (err) {
						// Ignore malformed query parameters.
					}
					return { collection, params };
				};

				const parseRouteState = (hash) => {
					const { collection, params } = parseRouteHash(hash);
					const state = { collection: collection || '' };
					if (params.skip !== undefined) {
						state.skip = toNonNegativeInteger(params.skip, 0);
					}
					if (params.limit !== undefined) {
						state.limit = toNonNegativeInteger(params.limit, DEFAULT_LIMIT);
					}
					if (params.query !== undefined) {
						state.query = params.query;
					}
					return state;
				};

				const isMeaningfulQueryText = (text) => {
					if (typeof text !== 'string') return false;
					const trimmed = text.trim();
					if (!trimmed) return false;
					try {
						const parsed = JSON.parse(trimmed);
						if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
							return Object.keys(parsed).length > 0;
						}
						return true;
					} catch (err) {
						return true;
					}
				};

				const buildRouteHash = ({ collection, skip, limit, query }) => {
					let path = '#/';
					if (collection) {
						path = `#/collections/${encodeURIComponent(collection)}`;
					}
					const params = new URLSearchParams();
					if (typeof skip === 'number' && skip > 0) {
						params.set('skip', String(skip));
					}
					if (typeof limit === 'number' && (limit !== DEFAULT_LIMIT || params.has('skip'))) {
						params.set('limit', String(limit));
					}
					if (typeof query === 'string' && isMeaningfulQueryText(query)) {
						params.set('query', query);
					}
					const queryString = params.toString();
					return queryString ? `${path}?${queryString}` : path;
				};

				let restoringRoute = false;
				let pendingRouteState = null;
				let programmaticNavigation = false;

				const syncRouteToCurrentState = (overrides = {}) => {
					if (typeof window === 'undefined') return;
					if (restoringRoute) return;
					const collection =
						overrides.collection !== undefined ? overrides.collection : selectedCollectionName.value;
					const skipValue =
						overrides.skip !== undefined
							? toNonNegativeInteger(overrides.skip, 0)
							: toNonNegativeInteger(collection ? appliedSkip.value : skip.value, 0);
					const limitValue =
						overrides.limit !== undefined
							? toNonNegativeInteger(overrides.limit, DEFAULT_LIMIT)
							: toNonNegativeInteger(collection ? appliedLimit.value : limit.value, DEFAULT_LIMIT);
					const queryValue = overrides.query !== undefined ? overrides.query : filterText.value;
					const nextHash = buildRouteHash({
						collection,
						skip: skipValue,
						limit: limitValue,
						query: queryValue,
					});
					if (window.location.hash === nextHash) return;
					programmaticNavigation = true;
					window.location.hash = nextHash;
				};

				const applyRouteState = (state) => {
					pendingRouteState = state;
					restoringRoute = true;
					if (state.limit !== undefined) {
						limit.value = toNonNegativeInteger(state.limit, DEFAULT_LIMIT);
						appliedLimit.value = toNonNegativeInteger(limit.value, DEFAULT_LIMIT);
					}
					if (!state.collection) {
						selectedCollectionName.value = '';
						const queryText =
							state.query !== undefined && state.query !== null && String(state.query).trim()
								? state.query
								: emptyJsonObjectText;
						filterText.value = queryText;
						filterError.value = '';
						const normalizedSkip = state.skip !== undefined ? toNonNegativeInteger(state.skip, 0) : 0;
						skip.value = normalizedSkip;
						appliedSkip.value = normalizedSkip;
						restoringRoute = false;
						pendingRouteState = null;
						return;
					}
					if (selectedCollectionName.value === state.collection) {
						selectedCollectionName.value = '';
					}
					selectedCollectionName.value = state.collection;
				};

				const currentRouteState = () => {
					if (typeof window === 'undefined') {
						return { collection: '' };
					}
					return parseRouteState(window.location.hash);
				};

				const handleHashChange = () => {
					if (programmaticNavigation) {
						programmaticNavigation = false;
						return;
					}
					const nextState = currentRouteState();
					applyRouteState(nextState);
				};

				const createActivityEntry = ({
					label,
					method,
					url,
					target,
					requestBody,
					requestHeaders,
				}) => {
					const normalizedMethod = typeof method === 'string' ? method.toUpperCase() : '';
					const normalizedUrl = typeof url === 'string' ? url : '';
					const normalizedHeaders = {};
					if (requestHeaders && typeof requestHeaders === 'object' && !Array.isArray(requestHeaders)) {
						Object.keys(requestHeaders).forEach((key) => {
							const headerValue = requestHeaders[key];
							if (typeof key !== 'string' || key.trim() === '' || headerValue === undefined || headerValue === null) return;
							normalizedHeaders[key] = String(headerValue);
						});
					}
					const hasContentTypeHeader = Object.keys(normalizedHeaders).some(
						(key) => key.toLowerCase() === 'content-type',
					);
					let normalizedBody = requestBody === undefined ? null : requestBody;
					if (normalizedBody && typeof normalizedBody === 'object') {
						try {
							normalizedBody = JSON.parse(JSON.stringify(normalizedBody));
						} catch (error) {
							// Keep the original reference if cloning fails.
						}
					}
					if (
						normalizedBody !== null &&
						normalizedMethod &&
						normalizedMethod !== 'GET' &&
						normalizedMethod !== 'HEAD' &&
						!hasContentTypeHeader &&
						typeof normalizedBody === 'object'
					) {
						normalizedHeaders['Content-Type'] = 'application/json';
					}
					const entry = {
						id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
						label,
						method: normalizedMethod || method || '',
						url: normalizedUrl,
						target: target || '',
						status: 'pending',
						statusCode: null,
						detail: 'Waiting for responseâ€¦',
						startedAt: new Date(),
						finishedAt: null,
						durationMs: null,
						request: {
							method: normalizedMethod || method || '',
							url: normalizedUrl,
							headers: normalizedHeaders,
							body: normalizedBody,
						},
					};
					activityLog.value.unshift(entry);
					if (activityLog.value.length > MAX_ACTIVITY_LOG_ENTRIES) {
						activityLog.value.splice(MAX_ACTIVITY_LOG_ENTRIES);
					}
					return entry;
				};

				const completeActivityEntry = (entry, { status = 'success', detail = '', statusCode } = {}) => {
					if (!entry) return;
					entry.status = status;
					entry.detail = detail;
					if (typeof statusCode === 'number') {
						entry.statusCode = statusCode;
					}
					entry.finishedAt = new Date();
					entry.durationMs = entry.finishedAt - entry.startedAt;
				};

				const failActivityEntry = (entry, error, { fallback } = {}) => {
					if (!entry) return;
					const statusCode = error?.response?.status;
					const detail = error?.response?.data?.error || error?.message || fallback || 'Request failed.';
					completeActivityEntry(entry, { status: 'error', detail, statusCode });
				};

				const resetExportState = () => {
					exportState.running = false;
					exportState.progress = '';
					exportState.error = '';
				};

				const attachRawLine = (target, rawLine) => {
					if (!target || typeof target !== 'object') return;
					Object.defineProperty(target, '__rawLine', {
						value: rawLine,
						enumerable: false,
						configurable: true,
						writable: false,
					});
				};

				const toJsonlLine = (row) => {
					if (!row) return null;
					if (typeof row === 'object') {
						if (typeof row.__rawLine === 'string') {
							return row.__rawLine;
						}
						if (Object.prototype.hasOwnProperty.call(row, '_raw') && typeof row._raw === 'string') {
							return row._raw;
						}
						try {
							return JSON.stringify(row);
						} catch (err) {
							return null;
						}
					}
					try {
						return JSON.stringify(row);
					} catch (err) {
						return null;
					}
				};

				const sanitizeFilename = (value) => {
					if (typeof value !== 'string' || !value) return 'collection';
					return value
						.toLowerCase()
						.replace(/[^a-z0-9-_]+/g, '_')
						.replace(/^_+|_+$/g, '') || 'collection';
				};

				const makeExportFilename = (collectionName) => {
					const safeName = sanitizeFilename(collectionName);
					const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
					return `inceptiondb-${safeName}-${timestamp}.jsonl`;
				};

				const downloadJsonl = (chunks, filename) => {
					const blob = new Blob(chunks, { type: 'application/x-ndjson' });
					const objectUrl = URL.createObjectURL(blob);
					const anchor = document.createElement('a');
					anchor.href = objectUrl;
					anchor.download = filename;
					document.body.appendChild(anchor);
					anchor.click();
					document.body.removeChild(anchor);
					URL.revokeObjectURL(objectUrl);
				};

				const detectCsvDelimiter = (sample) => {
					if (typeof sample !== 'string' || !sample) {
						return null;
					}
					const candidates = [',', ';', '\t', '|'];
					const lines = sample.split(/\r?\n/).slice(0, 5);
					let bestDelimiter = null;
					let bestScore = 0;
					candidates.forEach((candidate) => {
						let score = 0;
						lines.forEach((line) => {
							if (!line) return;
							const parts = line.split(candidate);
							if (parts.length > 1) {
								score += parts.length - 1;
							}
						});
						if (score > bestScore) {
							bestScore = score;
							bestDelimiter = candidate;
						}
					});
					return bestScore > 0 ? bestDelimiter : null;
				};

				const parseCsvRows = (text, delimiter) => {
					const rows = [];
					const sep = typeof delimiter === 'string' && delimiter.length > 0 ? delimiter : ',';
					let value = '';
					let row = [];
					let inQuotes = false;
					let i = 0;
					while (i < text.length) {
						const char = text[i];
						if (inQuotes) {
							if (char === '"') {
								if (text[i + 1] === '"') {
									value += '"';
									i += 1;
								} else {
									inQuotes = false;
								}
							} else {
								value += char;
							}
						} else if (char === '"') {
							inQuotes = true;
						} else if (char === sep) {
							row.push(value);
							value = '';
						} else if (char === '\n') {
							row.push(value);
							rows.push(row);
							row = [];
							value = '';
						} else if (char === '\r') {
							// ignore carriage returns; handled on next newline
						} else {
							value += char;
						}
						i += 1;
					}
					if (inQuotes) {
						throw new Error('Unclosed quoted value in CSV data.');
					}
					if (value !== '' || row.length > 0) {
						row.push(value);
						rows.push(row);
					}
					return rows;
				};

				const buildCsvDocuments = (rows, trimValues) => {
					if (!Array.isArray(rows) || rows.length === 0) {
						throw new Error('The CSV file is missing a header row.');
					}
					const headerRow = rows[0];
					const headers = headerRow.map((cell, idx) => {
						const header = typeof cell === 'string' ? cell.trim() : '';
						if (!header) {
							throw new Error(`Column ${idx + 1} header is empty.`);
						}
						return header;
					});
					if (headers.length === 0) {
						throw new Error('The CSV header row is empty.');
					}
					const documents = [];
					for (let i = 1; i < rows.length; i += 1) {
						const row = rows[i];
						if (!Array.isArray(row)) {
							continue;
						}
						const isEmpty = row.every((cell) => {
							if (cell === null || cell === undefined) return true;
							return String(cell).trim() === '';
						});
						if (isEmpty) {
							continue;
						}
						const doc = {};
						headers.forEach((header, idx) => {
							let cell = row[idx];
							if (cell === undefined || cell === null) {
								cell = '';
							}
							if (trimValues && typeof cell === 'string') {
								cell = cell.trim();
							}
							doc[header] = cell;
						});
						if (Object.keys(doc).length > 0) {
							documents.push(doc);
						}
					}
					return documents;
				};

				const onCsvFileChange = async (event) => {
					csvImportForm.error = '';
					csvImportForm.success = '';
					csvImportForm.progress = '';
					const files = event?.target?.files;
					const file = files && files[0] ? files[0] : null;
					csvImportForm.file = file;
					csvImportForm.fileName = file?.name || '';
					if (!file) {
						return;
					}
					try {
						const sampleText = await file.slice(0, 4096).text();
						const detected = detectCsvDelimiter(sampleText);
						if (detected) {
							csvImportForm.delimiter = detected;
						}
					} catch (err) {
						// Ignore auto-detection errors.
					}
				};

				const resetCsvImportForm = () => {
					if (csvImportForm.importing) {
						return;
					}
					csvImportForm.file = null;
					csvImportForm.fileName = '';
					csvImportForm.error = '';
					csvImportForm.success = '';
					csvImportForm.progress = '';
					csvImportForm.inputKey += 1;
				};

				const importCsv = async () => {
					csvImportForm.error = '';
					csvImportForm.success = '';
					csvImportForm.progress = '';
					if (!selectedCollection.value) {
						csvImportForm.error = 'Select a collection before importing.';
						return;
					}
					if (!csvImportForm.file) {
						csvImportForm.error = 'Choose a CSV file to import.';
						return;
					}
					let csvText;
					try {
						csvText = await csvImportForm.file.text();
					} catch (err) {
						csvImportForm.error = 'Failed to read the CSV file.';
						return;
					}
					if (!csvText || csvText.trim().length === 0) {
						csvImportForm.error = 'The selected file is empty.';
						return;
					}
					csvImportForm.progress = 'Parsing CSV fileâ€¦';
					const sanitizedText = csvText.replace(/^\ufeff/, '');
					let rows;
					try {
						rows = parseCsvRows(sanitizedText, csvImportForm.delimiter);
					} catch (err) {
						csvImportForm.progress = '';
						csvImportForm.error = `Failed to parse CSV: ${err.message}`;
						return;
					}
					if (!Array.isArray(rows) || rows.length === 0) {
						csvImportForm.progress = '';
						csvImportForm.error = 'The CSV file does not contain any rows.';
						return;
					}
					const meaningfulRows = rows.filter((row, index) => {
						if (!Array.isArray(row)) {
							return false;
						}
						if (index === 0) {
							return true;
						}
						return row.some((cell) => {
							if (cell === null || cell === undefined) return false;
							return String(cell).trim() !== '';
						});
					});
					if (meaningfulRows.length <= 1) {
						csvImportForm.progress = '';
						csvImportForm.error = 'The CSV file must include a header row and at least one data row.';
						return;
					}
					let documents;
					try {
						documents = buildCsvDocuments(meaningfulRows, csvImportForm.trimValues);
					} catch (err) {
						csvImportForm.progress = '';
						csvImportForm.error = err.message || 'Failed to process the CSV file.';
						return;
					}
					if (!documents || documents.length === 0) {
						csvImportForm.progress = '';
						csvImportForm.error = 'No documents were generated from the CSV file.';
						return;
					}
					const ndjsonPayload = documents.map((doc) => JSON.stringify(doc)).join('\n');
					csvImportForm.progress = `Uploading ${documents.length} ${documents.length === 1 ? 'record' : 'records'}â€¦`;
					csvImportForm.importing = true;
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:insert`;
					const entry = createActivityEntry({
						label: 'Import CSV',
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: ndjsonPayload,
						requestHeaders: { 'Content-Type': 'application/json' },
					});
					try {
						const resp = await http.post(url, ndjsonPayload, {
							headers: { 'Content-Type': 'application/json' },
							responseType: 'text',
							transformResponse: [(data) => data],
						});
						markConnectionOnline();
						csvImportForm.success = `Imported ${documents.length} ${documents.length === 1 ? 'document' : 'documents'} from the CSV file.`;
						csvImportForm.progress = '';
						csvImportForm.file = null;
						csvImportForm.fileName = '';
						csvImportForm.inputKey += 1;
						completeActivityEntry(entry, {
							detail: `Imported ${documents.length} ${documents.length === 1 ? 'document' : 'documents'} from CSV.`,
							statusCode: resp.status,
						});
						await runQuery();
						await loadCollections();
					} catch (error) {
						csvImportForm.progress = '';
						csvImportForm.error = error?.response?.data?.error || 'Failed to import the CSV file.';
						failActivityEntry(entry, error, { fallback: 'Failed to import the CSV file.' });
						handleRequestError(error);
					} finally {
						csvImportForm.importing = false;
					}
				};

				const normalizeDefaults = (defaults) => {
					if (!defaults || typeof defaults !== 'object' || Array.isArray(defaults)) {
						return {};
					}
					try {
						return JSON.parse(JSON.stringify(defaults));
					} catch (err) {
						const copy = {};
						Object.keys(defaults).forEach((key) => {
							copy[key] = defaults[key];
						});
						return copy;
					}
				};

				const formatDefaultsEditor = (defaults) => {
					const normalized = normalizeDefaults(defaults);
					if (Object.keys(normalized).length === 0) {
						return emptyJsonObjectText;
					}
					try {
						return JSON.stringify(normalized, null, 2);
					} catch (err) {
						return emptyJsonObjectText;
					}
				};

				const syncDefaultsFormWithCollection = (collection) => {
					const formatted = formatDefaultsEditor(collection?.defaults);
					defaultsForm.original = formatted;
					defaultsForm.draft = formatted;
					defaultsForm.error = '';
					defaultsForm.success = '';
					defaultsForm.saving = false;
				};

				const resetDefaultsForm = () => {
					defaultsForm.draft = defaultsForm.original;
					defaultsForm.error = '';
					defaultsForm.success = '';
				};

				const formatDuration = (ms) => {
					if (typeof ms !== 'number' || Number.isNaN(ms)) return '';
					if (ms < 1000) return `${ms} ms`;
					if (ms < 10000) return `${(ms / 1000).toFixed(2)} s`;
					return `${(ms / 1000).toFixed(1)} s`;
				};

				const formatActivityTime = (date) => {
					if (!(date instanceof Date)) return '';
					return timeFormatter.format(date);
				};

				const activityStatusLabel = (status) => {
					switch (status) {
						case 'success':
							return 'Success';
						case 'error':
							return 'Failed';
						default:
							return 'Pending';
					}
				};

				const activityStatusBadgeClass = (status) => {
					switch (status) {
						case 'success':
							return 'border-emerald-500/40 bg-emerald-500/10 text-emerald-300';
						case 'error':
							return 'border-rose-500/40 bg-rose-500/10 text-rose-300';
						default:
							return 'border-sky-500/40 bg-sky-500/10 text-sky-300';
					}
				};

				const activityMarkerClass = (entry) => {
					switch (entry?.status) {
						case 'success':
							return 'activity-marker--success';
						case 'error':
							return 'activity-marker--error';
						default:
							return 'activity-marker--pending';
					}
				};

				const activityMarkerTitle = (entry) => {
					if (!entry) return 'Request';
					if (entry.label) return entry.label;
					if (entry.method) return String(entry.method).toUpperCase();
					return 'Request';
				};

				const activityRequestHeaders = (entry) => {
					if (!entry?.request || typeof entry.request !== 'object') return [];
					const headers = entry.request.headers;
					if (!headers || typeof headers !== 'object') return [];
					return Object.keys(headers)
						.filter((key) => key && key.trim() !== '' && headers[key] !== undefined && headers[key] !== null)
						.map((key) => ({ key, value: String(headers[key]) }));
				};

				const activityRequestBody = (entry) => {
					if (!entry?.request) return '';
					const body = entry.request.body;
					if (body === undefined || body === null || body === '') return '';
					if (typeof body === 'string') return body;
					try {
						return JSON.stringify(body, null, 2);
					} catch (err) {
						try {
							return String(body);
						} catch (error) {
							return '';
						}
					}
				};

				const buildHttpRequest = (entry) => {
					if (!entry?.request) return '';
					const method = (entry.request.method || '').toUpperCase() || 'GET';
					const rawUrl = entry.request.url || '';
					if (!rawUrl) return '';
					let path = rawUrl;
					let host = '';
					try {
						const parsed = new URL(rawUrl, window.location.origin);
						host = parsed.host;
						path = `${parsed.pathname || '/'}${parsed.search || ''}` || '/';
					} catch (error) {
						path = rawUrl;
					}
					if (!path) {
						path = '/';
					}
					const lines = [`${method} ${path} HTTP/1.1`];
					const headers = activityRequestHeaders(entry);
					const hasHostHeader = headers.some(({ key }) => key.toLowerCase() === 'host');
					if (host && !hasHostHeader) {
						lines.push(`Host: ${host}`);
					}
					headers.forEach(({ key, value }) => {
						lines.push(`${key}: ${value}`);
					});
					const body = activityRequestBody(entry);
					if (body) {
						lines.push('');
						lines.push(body);
					}
					return lines.join('\n');
				};

				const buildJavascriptRequest = (entry) => {
					if (!entry?.request) return '';
					const method = (entry.request.method || '').toUpperCase() || 'GET';
					const rawUrl = entry.request.url || '';
					if (!rawUrl) return '';
					let absoluteUrl = rawUrl;
					try {
						absoluteUrl = new URL(rawUrl, window.location.origin).toString();
					} catch (error) {
						absoluteUrl = rawUrl;
					}
					const lines = [`const response = await fetch(${JSON.stringify(absoluteUrl)}, {`];
					lines.push(`  method: '${method}',`);
					const headers = activityRequestHeaders(entry);
					if (headers.length > 0) {
						lines.push('  headers: {');
						headers.forEach(({ key, value }) => {
							lines.push(`    ${JSON.stringify(key)}: ${JSON.stringify(value)},`);
						});
						const lastIndex = lines.length - 1;
						lines[lastIndex] = lines[lastIndex].replace(/,$/, '');
						lines.push('  },');
					}
					const body = entry.request.body;
					if (body !== undefined && body !== null && body !== '') {
						if (typeof body === 'string') {
							lines.push(`  body: ${JSON.stringify(body)},`);
						} else {
							try {
								const serialized = JSON.stringify(body, null, 2);
								lines.push('  body: JSON.stringify(');
								serialized.split('\n').forEach((line) => {
									lines.push(`    ${line}`);
								});
								lines.push('  ),');
							} catch (error) {
								lines.push(`  body: ${JSON.stringify(String(body))},`);
							}
						}
					}
					const lastLineIndex = lines.length - 1;
					if (lastLineIndex >= 1 && lines[lastLineIndex].trim().endsWith(',')) {
						lines[lastLineIndex] = lines[lastLineIndex].replace(/,$/, '');
					}
					lines.push('});');
					lines.push('');
					lines.push('if (!response.ok) {');
					lines.push("  throw new Error('Request failed');");
					lines.push('}');
					lines.push('');
					lines.push('const data = await response.json();');
					lines.push('console.log(data);');
					return lines.join('\n');
				};

				const escapeSingleQuotes = (value) => String(value).replace(/'/g, "'\"'\"'");

				const buildCurlCommand = (entry) => {
					if (!entry?.request) return '';
					const method = (entry.request.method || '').toUpperCase();
					const supportedMethods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'];
					if (!supportedMethods.includes(method)) return '';
					const rawUrl = entry.request.url || '';
					if (!rawUrl) return '';
					let absoluteUrl = rawUrl;
					try {
						absoluteUrl = new URL(rawUrl, window.location.origin).toString();
					} catch (error) {
						absoluteUrl = rawUrl;
					}
					const lines = [`curl -X ${method} '${escapeSingleQuotes(absoluteUrl)}'`];
					const headers = activityRequestHeaders(entry);
					headers.forEach(({ key, value }) => {
						lines.push(`  -H '${escapeSingleQuotes(`${key}: ${value}`)}'`);
					});
					const body = entry.request.body;
					if (body !== undefined && body !== null && body !== '') {
						let bodyString = '';
						if (typeof body === 'string') {
							bodyString = body;
						} else {
							try {
								bodyString = JSON.stringify(body);
							} catch (error) {
								bodyString = String(body);
							}
						}
						lines.push(`  --data-raw '${escapeSingleQuotes(bodyString)}'`);
					}
					return lines.join(' \\\n');
				};

				const buildGoRequest = (entry) => {
					if (!entry?.request) return '';
					const method = (entry.request.method || '').toUpperCase() || 'GET';
					const rawUrl = entry.request.url || '';
					if (!rawUrl) return '';
					let absoluteUrl = rawUrl;
					try {
						absoluteUrl = new URL(rawUrl, window.location.origin).toString();
					} catch (error) {
						absoluteUrl = rawUrl;
					}

					const headers = activityRequestHeaders(entry);
					const body = entry.request.body;

					const goImports = new Set(['"fmt"', '"io"', '"log"', '"net/http"']);
					let bodyDeclaration = '';
					let bodyReference = 'nil';

					if (body !== undefined && body !== null && body !== '') {
						goImports.add('"strings"');
						let bodyString = '';
						if (typeof body === 'string') {
							bodyString = body;
						} else {
							try {
								bodyString = JSON.stringify(body, null, 2);
							} catch (error) {
								bodyString = String(body);
							}
						}
						bodyDeclaration = `\tpayload := strings.NewReader(${JSON.stringify(bodyString)})`;
						bodyReference = 'payload';
					}

					const lines = ['package main', '', 'import ('];
					Array.from(goImports)
						.sort()
						.forEach((imp) => {
							lines.push(`\t${imp}`);
						});
					lines.push(')', '', 'func main() {', '\tclient := &http.Client{}');
					if (bodyDeclaration) {
						lines.push(bodyDeclaration);
					}
					lines.push(
						`\treq, err := http.NewRequest(${JSON.stringify(method)}, ${JSON.stringify(absoluteUrl)}, ${bodyReference})`
					);
					lines.push('\tif err != nil {', '\t\tlog.Fatal(err)', '\t}');
					if (headers.length > 0) {
						lines.push('');
						headers.forEach(({ key, value }) => {
							lines.push(`\treq.Header.Set(${JSON.stringify(key)}, ${JSON.stringify(value)})`);
						});
					}
					lines.push(
						'',
						'\tresp, err := client.Do(req)',
						'\tif err != nil {',
						'\t\tlog.Fatal(err)',
						'\t}',
						'\tdefer resp.Body.Close()',
						'',
						'\tbody, err := io.ReadAll(resp.Body)',
						'\tif err != nil {',
						'\t\tlog.Fatal(err)',
						'\t}',
						'\tfmt.Println(string(body))',
						'}'
					);

					return lines.join('\n');
				};

				const buildPythonRequest = (entry) => {
					if (!entry?.request) return '';
					const method = (entry.request.method || '').toUpperCase() || 'GET';
					const rawUrl = entry.request.url || '';
					if (!rawUrl) return '';
					let absoluteUrl = rawUrl;
					try {
						absoluteUrl = new URL(rawUrl, window.location.origin).toString();
					} catch (error) {
						absoluteUrl = rawUrl;
					}

					const headers = activityRequestHeaders(entry);
					const body = entry.request.body;

					const lines = ['import requests'];
					let payloadArgument = '';
					if (body !== undefined && body !== null && body !== '') {
						if (typeof body === 'string') {
							lines.push('', `payload = ${JSON.stringify(body)}`);
							payloadArgument = 'data=payload';
						} else {
							let serialized = '';
							try {
								serialized = JSON.stringify(body, null, 2);
							} catch (error) {
								serialized = JSON.stringify(String(body));
							}
							lines.unshift('import json');
							lines.push('');
							lines.push('payload = json.loads("""');
							serialized.split('\n').forEach((line) => {
								lines.push(line);
							});
							lines.push('""")');
							payloadArgument = 'json=payload';
						}
					}

					lines.push('', `url = ${JSON.stringify(absoluteUrl)}`);

					if (headers.length > 0) {
						lines.push('headers = {');
						headers.forEach(({ key, value }) => {
							lines.push(`    ${JSON.stringify(key)}: ${JSON.stringify(value)},`);
						});
						const lastIndex = lines.length - 1;
						lines[lastIndex] = lines[lastIndex].replace(/,$/, '');
						lines.push('}');
					}

					const requestArgs = [`${JSON.stringify(method)}`, 'url'];
					if (headers.length > 0) {
						requestArgs.push('headers=headers');
					}
					if (payloadArgument) {
						requestArgs.push(payloadArgument);
					}
					lines.push('', `response = requests.request(${requestArgs.join(', ')})`);
					lines.push('print(response.text)');

					return lines.join('\n');
				};

				const buildPhpRequest = (entry) => {
					if (!entry?.request) return '';
					const method = (entry.request.method || '').toUpperCase() || 'GET';
					const rawUrl = entry.request.url || '';
					if (!rawUrl) return '';
					let absoluteUrl = rawUrl;
					try {
						absoluteUrl = new URL(rawUrl, window.location.origin).toString();
					} catch (error) {
						absoluteUrl = rawUrl;
					}

					const headers = activityRequestHeaders(entry);
					const body = entry.request.body;

					const lines = ['<?php', '', '$curl = curl_init();', '', 'curl_setopt_array($curl, ['];
					lines.push(`    CURLOPT_URL => ${JSON.stringify(absoluteUrl)},`);
					lines.push('    CURLOPT_RETURNTRANSFER => true,');
					lines.push(`    CURLOPT_CUSTOMREQUEST => ${JSON.stringify(method)},`);

					if (headers.length > 0) {
						lines.push('    CURLOPT_HTTPHEADER => [');
						headers.forEach(({ key, value }) => {
							lines.push(`        ${JSON.stringify(`${key}: ${value}`)},`);
						});
						const lastIndex = lines.length - 1;
						lines[lastIndex] = lines[lastIndex].replace(/,$/, '');
						lines.push('    ],');
					}

					if (body !== undefined && body !== null && body !== '') {
						let bodyString = '';
						if (typeof body === 'string') {
							bodyString = body;
						} else {
							try {
								bodyString = JSON.stringify(body);
							} catch (error) {
								bodyString = String(body);
							}
						}
						lines.push(`    CURLOPT_POSTFIELDS => ${JSON.stringify(bodyString)},`);
					}

					lines.push(']);', '', '$response = curl_exec($curl);');
					lines.push('');
					lines.push('if ($response === false) {');
					lines.push('    throw new RuntimeException(curl_error($curl));');
					lines.push('}');
					lines.push('');
					lines.push('curl_close($curl);');
					lines.push('');
					lines.push('echo $response;');

					return lines.join('\n');
				};

				const activityRequestTabDefinitions = [
					{ id: 'http', label: 'HTTP', builder: buildHttpRequest },
					{ id: 'javascript', label: 'JavaScript', builder: buildJavascriptRequest },
					{ id: 'golang', label: 'Golang', builder: buildGoRequest },
					{ id: 'python', label: 'Python', builder: buildPythonRequest },
					{ id: 'php', label: 'PHP', builder: buildPhpRequest },
					{ id: 'curl', label: 'cURL', builder: buildCurlCommand },
				];

				const activityRequestTabEntries = computed(() => {
					const entry = selectedActivityEntry.value;
					if (!entry) return [];
					return activityRequestTabDefinitions
						.map((tab) => {
							const content = tab.builder(entry);
							if (!content || String(content).trim() === '') {
								return null;
							}
							return { id: tab.id, label: tab.label, content };
						})
						.filter(Boolean);
				});

				const activeActivityRequestTabContent = computed(() => {
					const tabs = activityRequestTabEntries.value;
					if (!tabs.length) return '';
					const active = tabs.find((tab) => tab.id === selectedActivityRequestTab.value);
					return active ? active.content : tabs[0].content;
				});

				watch(activityRequestTabEntries, (tabs) => {
					if (!Array.isArray(tabs) || tabs.length === 0) {
						selectedActivityRequestTab.value = '';
						return;
					}
					if (!tabs.some((tab) => tab.id === selectedActivityRequestTab.value)) {
						selectedActivityRequestTab.value = tabs[0].id;
					}
				});

				const showActivityModal = () => {
					const modalEl = activityModal.value;
					if (!modalEl) return;

					if (typeof modalEl.showModal === 'function') {
						if (!modalEl.open) {
							modalEl.showModal();
						}
					} else {
						modalEl.setAttribute('open', '');
						modalEl.style.display = 'block';
					}

					modalOpen.value = true;
				};

				const hideActivityModal = () => {
					const modalEl = activityModal.value;
					if (!modalEl) return;

					if (typeof modalEl.close === 'function') {
						if (modalEl.open) {
							modalEl.close();
						}
					} else {
						modalEl.removeAttribute('open');
						modalEl.style.display = 'none';
					}

					modalOpen.value = false;
				};

				const openActivityDetail = (entry) => {
					if (!entry) {
						closeActivityDetail();
						return;
					}

					selectedActivityEntry.value = entry;
					selectedActivityRequestTab.value = 'http';
					activityDetailOpen.value = true;
					modalMode.value = 'activity';
					showActivityModal();
				};

				const closeActivityDetail = () => {
					activityDetailOpen.value = false;
					selectedActivityEntry.value = null;
					hideActivityModal();
				};

				const closeActivityModal = () => {
					if (modalMode.value === 'activity' && activityDetailOpen.value) {
						closeActivityDetail();
						return;
					}

					hideActivityModal();
				};

				const clearActivityLog = () => {
					activityLog.value = [];
					closeActivityDetail();
				};

				watch(activityLog, (entries) => {
					if (!activityDetailOpen.value || !selectedActivityEntry.value) return;
					const stillExists = entries.some(entry => entry.id === selectedActivityEntry.value.id);
					if (!stillExists) {
						closeActivityDetail();
					}
				}, { deep: true });

				const handleKeydown = (event) => {
					if (event.key === 'Escape' && modalOpen.value) {
						event.preventDefault();
						closeActivityModal();
					}
				};

				const resetSizeMetrics = () => {
					sizeMetrics.loading = false;
					sizeMetrics.error = '';
					sizeMetrics.data = null;
					sizeMetrics.updatedAt = null;
				};

				const connectionStatusLabel = computed(() => {
					if (connectionStatus.state === 'online') return 'Connected';
					if (connectionStatus.state === 'degraded') return 'Degraded';
					if (connectionStatus.state === 'offline') return 'Offline';
					return connectionStatus.isChecking ? 'Checkingâ€¦' : 'Unknown';
				});

				const connectionStatusDescription = computed(() => {
					if (connectionStatus.state === 'unknown' && connectionStatus.isChecking) {
						return 'Verifying API availabilityâ€¦';
					}
					const segments = [];
					if (connectionStatus.detail) segments.push(connectionStatus.detail);
					if (connectionStatus.checkedAt instanceof Date) {
						segments.push(`Updated at ${timeFormatter.format(connectionStatus.checkedAt)}`);
					}
					return segments.join(' â€¢ ');
				});

				const connectionStatusBadgeClass = computed(() => {
					switch (connectionStatus.state) {
						case 'online':
							return 'border border-emerald-500/40 bg-emerald-500/10 text-emerald-200';
						case 'degraded':
							return 'border border-amber-500/40 bg-amber-500/10 text-amber-200';
						case 'offline':
							return 'border border-rose-500/40 bg-rose-500/10 text-rose-200';
						default:
							return 'border border-slate-500/30 bg-slate-500/10 text-slate-200';
					}
				});

				const connectionStatusDotClass = computed(() => {
					const base = 'h-2 w-2 rounded-full';
					const pulse = connectionStatus.isChecking ? ' animate-pulse' : '';
					switch (connectionStatus.state) {
						case 'online':
							return base + ' bg-emerald-400' + pulse;
						case 'degraded':
							return base + ' bg-amber-400' + pulse;
						case 'offline':
							return base + ' bg-rose-400' + pulse;
						default:
							return base + ' bg-slate-300' + pulse;
					}
				});

				const connectionStatusButtonLabel = computed(() => (connectionStatus.isChecking ? 'Checkingâ€¦' : 'Check now'));
				const connectionStatusChecking = computed(() => connectionStatus.isChecking);

				const selectedCollection = computed(() => collections.value.find(c => c.name === selectedCollectionName.value) || null);
				const activeIndex = computed(() => indexes.value.find(idx => idx.name === selectedIndexName.value) || null);
				const offset = computed(() => toNonNegativeInteger(skip.value, 0));
				const disablePrev = computed(() => offset.value <= 0);
				const disableNext = computed(() => {
					const limitValue = toNonNegativeInteger(limit.value, 0);
					if (limitValue === 0) return true;
					return queryRows.value.length < limitValue;
				});
				const pageInfo = computed(() => {
					const count = queryRows.value.length;
					if (count === 0) {
						return 'No results on this page.';
					}
					const start = offset.value + 1;
					const end = offset.value + count;
					const total = selectedCollection.value?.total;
					if (typeof total === 'number') {
						return `Showing ${start}â€“${end} of ${total}`;
					}
					return `Showing ${start}â€“${end}`;
				});

				const sizeMetricsEntries = computed(() => {
					const source = sizeMetrics.data;
					if (!source || typeof source !== 'object' || Array.isArray(source)) return [];
					return Object.keys(source)
						.map((key) => {
							const rawValue = source[key];
							const isNumber = typeof rawValue === 'number' && Number.isFinite(rawValue);
							const value = isNumber ? formatBytes(rawValue) : String(rawValue);
							const tooltip = isNumber
								? `${numberFormatter.format(rawValue)} bytes`
								: rawValue === null || rawValue === undefined
									? ''
									: String(rawValue);
							let priority = 3;
							if (key === 'memory') priority = 0;
							else if (key === 'disk') priority = 1;
							else if (typeof key === 'string' && key.startsWith('index.')) priority = 2;
							return {
								key,
								label: formatSizeMetricLabel(key),
								value,
								tooltip,
								priority,
							};
						})
						.sort((a, b) => {
							if (a.priority !== b.priority) return a.priority - b.priority;
							return a.label.localeCompare(b.label);
						})
						.map(({ priority, ...rest }) => rest);
				});

				const sizeMetricsUpdatedLabel = computed(() => {
					if (!(sizeMetrics.updatedAt instanceof Date)) return '';
					return timeFormatter.format(sizeMetrics.updatedAt);
				});

				const tableColumns = computed(() => {
					const columns = new Set();
					queryRows.value.forEach((row) => {
						if (!row || typeof row !== 'object' || Array.isArray(row)) return;
						Object.keys(row).forEach((key) => {
							if (key === '_raw') return;
							columns.add(key);
						});
					});
					const ordered = Array.from(columns);
					ordered.sort((a, b) => {
						if (a === 'id') return -1;
						if (b === 'id') return 1;
						return a.localeCompare(b);
					});
					return ordered;
				});

				const prettyTotal = (n) => {
					if (typeof n !== 'number') return n;
					if (n >= 1_000_000) return (n / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
					if (n >= 1_000) return (n / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
					return n;
				};

				const formatBytes = (value) => {
					const bytes = Number(value);
					if (!Number.isFinite(bytes)) {
						if (value === null || value === undefined) return '';
						return String(value);
					}
					const abs = Math.abs(bytes);
					if (abs < 1024) {
						return `${numberFormatter.format(bytes)} B`;
					}
					const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
					const exponent = Math.min(Math.floor(Math.log(abs) / Math.log(1024)), units.length - 1);
					const scaled = bytes / 1024 ** exponent;
					const formatted = Math.abs(scaled) >= 10 ? scaled.toFixed(0) : scaled.toFixed(1);
					return `${formatted.replace(/\.0$/, '')} ${units[exponent]}`;
				};

				const formatSizeMetricLabel = (key) => {
					if (key === 'memory') return 'In-memory data';
					if (key === 'disk') return 'Disk file';
					if (typeof key === 'string' && key.startsWith('index.')) {
						const suffix = key.slice(6) || 'unnamed';
						return `Index "${suffix}"`;
					}
					if (!key) return 'Metric';
					return String(key).replace(/\./g, ' â€º ');
				};

				const isSelected = (name) => selectedCollectionName.value === name;

				const selectResultsView = (mode) => {
					resultsViewMode.value = mode === 'table' ? 'table' : 'cards';
				};

				const toggleCreateForm = () => {
					createForm.open = !createForm.open;
					createForm.error = '';
				};

				const getCardLoadState = (card, collectionName) => {
					if (!collectionName) return 'idle';
					const tracker = cardLoadTracker[card];
					if (!tracker) return 'idle';
					return tracker[collectionName] || 'idle';
				};

				const setCardLoadState = (card, collectionName, state) => {
					if (!collectionName) return;
					if (!cardLoadTracker[card]) {
						cardLoadTracker[card] = {};
					}
					cardLoadTracker[card][collectionName] = state;
				};

				const clearCardLoadState = (card, collectionName) => {
					if (!collectionName) return;
					if (!cardLoadTracker[card]) return;
					delete cardLoadTracker[card][collectionName];
				};

				const toggleCard = (name) => {
					if (!Object.prototype.hasOwnProperty.call(collapsibleCards, name)) {
						return;
					}
					collapsibleCards[name] = !collapsibleCards[name];
					if (!collapsibleCards[name] && name === 'defaults') {
						defaultsHelpOpen.value = false;
					}
					if (collapsibleCards[name] && selectedCollection.value) {
						const collectionName = selectedCollection.value.name;
						if (name === 'metrics') {
							const state = getCardLoadState('metrics', collectionName);
							if (state === 'idle' || state === 'failed') {
								refreshSizeMetrics();
							}
						} else if (name === 'indexes') {
							const state = getCardLoadState('indexes', collectionName);
							if (state === 'idle' || state === 'failed') {
								loadIndexes();
							}
						}
					}
				};

				const resetIndexForm = () => {
					indexForm.name = '';
					indexForm.type = 'map';
					indexForm.field = '';
					indexForm.fieldsText = '';
					indexForm.sparse = false;
					indexForm.unique = false;
					indexForm.submitting = false;
				};

				const toggleIndexForm = () => {
					if (indexForm.open) {
						indexForm.open = false;
					} else {
						resetIndexForm();
						indexForm.open = true;
					}
					indexMessages.error = '';
					indexMessages.success = '';
				};

				const ensureEditState = (id) => {
					if (!editingDocuments[id]) {
						editingDocuments[id] = {
							open: false,
							draft: '',
							original: '',
							parsedOriginal: null,
							saving: false,
							error: '',
							success: '',
						};
					}
					return editingDocuments[id];
				};

				const clearEditingDocuments = () => {
					Object.keys(editingDocuments).forEach((key) => {
						delete editingDocuments[key];
					});
				};

				const documentId = (row) => {
					if (!row || typeof row !== 'object' || Array.isArray(row)) return null;
					if (Object.prototype.hasOwnProperty.call(row, '_raw')) return null;
					if (!Object.prototype.hasOwnProperty.call(row, 'id')) return null;
					const value = row.id;
					if (value === undefined || value === null) return null;
					return String(value);
				};

				const canEditDocument = (row) => documentId(row) !== null;

				const isEditingRow = (row) => {
					const id = documentId(row);
					if (!id) return false;
					const state = editingDocuments[id];
					return !!(state && state.open);
				};

				const openEditingRows = computed(() => queryRows.value
					.map((row, idx) => {
						const id = documentId(row);
						if (!id) return null;
						const state = editingDocuments[id];
						if (!state || !state.open) return null;
						return {
							id,
							row,
							state,
							position: offset.value + idx + 1,
						};
					})
					.filter(Boolean));
				const quickSearchResultText = computed(() => {
					if (!quickSearch.result || !quickSearch.result.document) return '';
					try {
						return JSON.stringify(quickSearch.result.document, null, 2);
					} catch (error) {
						return '';
					}
				});
				const quickSearchSourceLabel = computed(() => {
					if (!quickSearch.result || !quickSearch.result.source) return '';
					const source = quickSearch.result.source;
					if (source.type === 'index') {
						return source.name ? `Index ${source.name}` : 'Index';
					}
					if (source.type === 'fullscan') {
						return 'Full scan';
					}
					return source.type || '';
				});

				const openEditRow = (row) => {
					const id = documentId(row);
					if (!id) return;
					const state = ensureEditState(id);
					const snapshot = JSON.parse(JSON.stringify(row));
					const formatted = JSON.stringify(snapshot, null, 2);
					state.open = true;
					state.error = '';
					state.success = '';
					state.saving = false;
					state.parsedOriginal = snapshot;
					state.original = formatted;
					state.draft = formatted;
				};

				const closeEditRow = (row) => {
					const id = documentId(row);
					if (!id) return;
					const state = editingDocuments[id];
					if (!state || state.saving) return;
					state.open = false;
					state.error = '';
					state.success = '';
					state.draft = state.original;
				};

				const onEditDraftInput = (row) => {
					const id = documentId(row);
					if (!id) return;
					const state = editingDocuments[id];
					if (!state) return;
					state.error = '';
					if (state.success) {
						state.success = '';
					}
				};

				const isPlainObject = (value) => Object.prototype.toString.call(value) === '[object Object]';

				const deepEqual = (a, b) => {
					if (a === b) return true;
					if (typeof a !== typeof b) return false;
					if (a === null || b === null) return false;
					if (Array.isArray(a)) {
						if (!Array.isArray(b) || a.length !== b.length) return false;
						for (let i = 0; i < a.length; i += 1) {
							if (!deepEqual(a[i], b[i])) return false;
						}
						return true;
					}
					if (isPlainObject(a)) {
						if (!isPlainObject(b)) return false;
						const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
						for (const key of keys) {
							if (!deepEqual(a[key], b[key])) {
								return false;
							}
						}
						return true;
					}
					return false;
				};

				const buildMergePatch = (original, updated) => {
					if (deepEqual(original, updated)) {
						return undefined;
					}
					if (Array.isArray(original) || Array.isArray(updated)) {
						if (Array.isArray(original) && Array.isArray(updated) && deepEqual(original, updated)) {
							return undefined;
						}
						return updated;
					}
					if (!isPlainObject(original) || !isPlainObject(updated)) {
						return updated;
					}
					const patch = {};
					const keys = new Set([...Object.keys(original), ...Object.keys(updated)]);
					keys.forEach((key) => {
						if (!Object.prototype.hasOwnProperty.call(updated, key)) {
							patch[key] = null;
							return;
						}
						const child = buildMergePatch(original[key], updated[key]);
						if (child !== undefined) {
							patch[key] = child;
						}
					});
					if (Object.keys(patch).length === 0) {
						return undefined;
					}
					return patch;
				};

				const applyDocumentUpdate = (target, source) => {
					if (!target || typeof target !== 'object' || !source || typeof source !== 'object') return;
					Object.keys(target).forEach((key) => {
						if (!Object.prototype.hasOwnProperty.call(source, key)) {
							delete target[key];
						}
					});
					Object.keys(source).forEach((key) => {
						target[key] = source[key];
					});
				};

				const saveEditRow = async (row) => {
					const id = documentId(row);
					if (!id || !selectedCollection.value) return;
					const state = ensureEditState(id);
					if (state.saving) return;
					state.error = '';
					state.success = '';
					let parsed;
					try {
						parsed = JSON.parse(state.draft);
					} catch (err) {
						state.error = 'Invalid JSON: ' + err.message;
						return;
					}
					if (!Object.prototype.hasOwnProperty.call(parsed, 'id')) {
						state.error = 'The document must include an "id" field.';
						return;
					}
					if (parsed.id !== row.id) {
						state.error = 'The "id" field cannot be changed.';
						return;
					}
					const originalSnapshot = state.parsedOriginal || JSON.parse(JSON.stringify(row));
					const patch = buildMergePatch(originalSnapshot, parsed);
					let preparedPatch = patch;
					if (preparedPatch && typeof preparedPatch === 'object' && !Array.isArray(preparedPatch)) {
						delete preparedPatch.id;
						if (Object.keys(preparedPatch).length === 0) {
							preparedPatch = undefined;
						}
					}
					if (!preparedPatch) {
						state.error = 'No changes detected.';
						return;
					}
					state.saving = true;
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:patch`;
					const requestPayload = {
						filter: { id: row.id },
						patch: preparedPatch,
						limit: 1,
					};
					const entry = createActivityEntry({
						label: `Edit document ${id}`,
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: requestPayload,
					});
					try {
						const resp = await http.post(url, requestPayload);
						markConnectionOnline();
						completeActivityEntry(entry, {
							detail: `Document ${id} updated successfully.`,
							statusCode: resp.status,
						});
						applyDocumentUpdate(row, parsed);
						state.parsedOriginal = JSON.parse(JSON.stringify(parsed));
						state.original = JSON.stringify(parsed, null, 2);
						state.draft = state.original;
						state.success = 'Document updated successfully.';
					} catch (error) {
						state.error = error?.response?.data?.error || 'Failed to update the document.';
						failActivityEntry(entry, error, { fallback: 'Failed to update the document.' });
						handleRequestError(error);
					} finally {
						state.saving = false;
					}
				};

				const createIndex = async () => {
					if (!selectedCollection.value || indexForm.submitting) return;
					indexMessages.error = '';
					indexMessages.success = '';
					const name = indexForm.name.trim();
					if (!name) {
						indexMessages.error = 'Provide a name for the index.';
						return;
					}
					const payload = {
						name,
						type: indexForm.type,
					};
					if (indexForm.type === 'map') {
						const field = indexForm.field.trim();
						if (!field) {
							indexMessages.error = 'Provide the field to index.';
							return;
						}
						payload.field = field;
						payload.sparse = !!indexForm.sparse;
					} else if (indexForm.type === 'fts') {
						const field = indexForm.field.trim();
						if (!field) {
							indexMessages.error = 'Provide the field to index.';
							return;
						}
						payload.field = field;
					} else if (indexForm.type === 'btree') {
						const fields = indexForm.fieldsText
							.split(',')
							.map((part) => part.trim())
							.filter(Boolean);
						if (!fields.length) {
							indexMessages.error = 'Add at least one field for the index.';
							return;
						}
						payload.fields = fields;
						payload.sparse = !!indexForm.sparse;
						payload.unique = !!indexForm.unique;
					} else {
						indexMessages.error = 'Unsupported index type.';
						return;
					}
					indexForm.submitting = true;
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:createIndex`;
					const entry = createActivityEntry({
						label: `Create index ${name}`,
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: payload,
					});
					try {
						const resp = await http.post(url, payload);
						markConnectionOnline();
						indexMessages.success = `Index "${name}" created successfully.`;
						indexForm.open = false;
						resetIndexForm();
						completeActivityEntry(entry, {
							detail: `Index "${name}" created successfully.`,
							statusCode: resp.status,
						});
						await loadIndexes();
						selectedIndexName.value = name;
					} catch (error) {
						indexMessages.error = error?.response?.data?.error || 'Failed to create the index.';
						failActivityEntry(entry, error, { fallback: 'Failed to create the index.' });
						handleRequestError(error);
					} finally {
						indexForm.submitting = false;
					}
				};

				const removeIndex = async (index) => {
					if (!selectedCollection.value) return;
					indexMessages.error = '';
					indexMessages.success = '';
					const confirmMessage = `Delete the index "${index.name}"? This action cannot be undone.`;
					const ok = window.confirm(confirmMessage);
					if (!ok) return;
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:dropIndex`;
					const requestPayload = { name: index.name };
					const entry = createActivityEntry({
						label: `Delete index ${index.name}`,
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: requestPayload,
					});
					try {
						const resp = await http.post(url, requestPayload);
						markConnectionOnline();
						if (selectedIndexName.value === index.name) {
							selectedIndexName.value = '';
						}
						indexMessages.success = `Index "${index.name}" deleted successfully.`;
						completeActivityEntry(entry, {
							detail: `Index "${index.name}" deleted successfully.`,
							statusCode: resp.status,
						});
						await loadIndexes();
					} catch (error) {
						indexMessages.error = error?.response?.data?.error || 'Failed to delete the index.';
						failActivityEntry(entry, error, { fallback: 'Failed to delete the index.' });
						handleRequestError(error);
					}
				};

				const markConnectionOnline = (detail = 'All systems operational') => {
					connectionStatus.state = 'online';
					connectionStatus.detail = detail;
					connectionStatus.checkedAt = new Date();
					connectionStatus.isChecking = false;
				};

				const markConnectionDegraded = (detail) => {
					connectionStatus.state = 'degraded';
					connectionStatus.detail = detail;
					connectionStatus.checkedAt = new Date();
					connectionStatus.isChecking = false;
				};

				const markConnectionOffline = (detail) => {
					connectionStatus.state = 'offline';
					connectionStatus.detail = detail;
					connectionStatus.checkedAt = new Date();
					connectionStatus.isChecking = false;
				};

				const beginConnectionCheck = () => {
					connectionStatus.isChecking = true;
					if (connectionStatus.state === 'unknown') {
						connectionStatus.detail = 'Checking backend statusâ€¦';
					}
				};

				const handleRequestError = (error, { context = 'request' } = {}) => {
					if (error?.response) {
						const status = Number(error.response.status);
						if (status >= 500) {
							markConnectionDegraded(`Server error (HTTP ${status})`);
						} else if (context === 'check') {
							markConnectionDegraded(`Unexpected response (HTTP ${status})`);
						} else {
							connectionStatus.isChecking = false;
						}
					} else {
						const message = error?.message ? `Network error: ${error.message}` : 'Unable to reach the API.';
						markConnectionOffline(message);
					}
					return error;
				};

				let statusPoller = null;
				let statusPromise = null;
				let lastQueryParameters = null;

				const checkBackendStatus = async () => {
					if (statusPromise) return statusPromise;
					beginConnectionCheck();
					statusPromise = http
						.get('/v1/collections')
						.then(() => {
							markConnectionOnline();
						})
						.catch((error) => {
							handleRequestError(error, { context: 'check' });
						})
						.finally(() => {
							connectionStatus.isChecking = false;
							statusPromise = null;
						});
					return statusPromise;
				};

				const refreshConnectionStatus = () => {
					if (connectionStatus.isChecking) return;
					checkBackendStatus();
				};

				const selectCollection = (name) => {
					if (selectedCollectionName.value === name) {
						selectedCollectionName.value = '';
					} else {
						selectedCollectionName.value = name;
					}
				};

				const resetRangeFields = () => {
					Object.keys(rangeFrom).forEach((key) => delete rangeFrom[key]);
					Object.keys(rangeTo).forEach((key) => delete rangeTo[key]);
					const index = activeIndex.value;
					if (index && index.type === 'btree') {
						(index.fields || []).forEach((field) => {
							rangeFrom[field] = '';
							rangeTo[field] = '';
						});
					}
				};

				watch(
					() => indexForm.type,
					() => {
						indexForm.field = '';
						indexForm.fieldsText = '';
						indexForm.sparse = false;
						indexForm.unique = false;
						indexMessages.error = '';
					},
				);

				watch(activeIndex, () => {
					mapValue.value = '';
					ftsMatch.value = '';
					reverse.value = false;
					resetRangeFields();
				});

				watch(selectedCollection, async (collection) => {
					resetQuickSearchState(!collection);
					const routeSnapshot = restoringRoute ? pendingRouteState : null;
					indexes.value = [];
					selectedIndexName.value = '';
					mapValue.value = '';
					ftsMatch.value = '';
					reverse.value = false;
					resetRangeFields();
					const routeQueryText =
						routeSnapshot && routeSnapshot.query !== undefined && routeSnapshot.query !== null
							? String(routeSnapshot.query)
							: '';
					filterText.value = routeQueryText.trim() ? routeQueryText : '{\n\n}';
					filterError.value = '';
					const normalizedSkip =
						routeSnapshot && routeSnapshot.skip !== undefined
							? toNonNegativeInteger(routeSnapshot.skip, 0)
							: 0;
					skip.value = normalizedSkip;
					appliedSkip.value = normalizedSkip;
					if (routeSnapshot && routeSnapshot.limit !== undefined) {
						limit.value = toNonNegativeInteger(routeSnapshot.limit, DEFAULT_LIMIT);
					}
					appliedLimit.value = toNonNegativeInteger(limit.value, DEFAULT_LIMIT);
					queryRows.value = [];
					queryError.value = '';
					queryStats.elapsed = '';
					queryStats.returned = 0;
					indexForm.open = false;
					resetIndexForm();
					indexMessages.error = '';
					indexMessages.success = '';
					lastQueryParameters = null;
					resetExportState();
					resetSizeMetrics();
					syncDefaultsFormWithCollection(collection);
					if (!collection) {
						if (!restoringRoute) {
							syncRouteToCurrentState({
								collection: '',
								skip: normalizedSkip,
								limit: limit.value,
								query: filterText.value,
							});
						}
						return;
					}
					clearCardLoadState('metrics', collection.name);
					clearCardLoadState('indexes', collection.name);
					if (collapsibleCards.metrics) {
						await refreshSizeMetrics();
					}
					if (collapsibleCards.indexes) {
						await loadIndexes();
					}
					await runQuery();
					if (restoringRoute) {
						restoringRoute = false;
						pendingRouteState = null;
					}
				});

				const loadCollections = async () => {
					collectionsLoading.value = true;
					collectionsError.value = '';
					const entry = createActivityEntry({
						label: 'List collections',
						method: 'GET',
						url: '/v1/collections',
					});
					try {
						const resp = await http.get('/v1/collections');
						markConnectionOnline();
						const list = Array.isArray(resp.data) ? resp.data.slice() : [];
						list.sort((a, b) => a.name.localeCompare(b.name));
						collections.value = list;
						completeActivityEntry(entry, {
							detail: `Loaded ${list.length} collections.`,
							statusCode: resp.status,
						});
						if (selectedCollectionName.value) {
							const exists = list.some((item) => item.name === selectedCollectionName.value);
							if (!exists) {
								selectedCollectionName.value = '';
							}
						}
					} catch (error) {
						collectionsError.value = error?.response?.data?.error || 'Failed to load collections.';
						failActivityEntry(entry, error, { fallback: 'Failed to load collections.' });
						handleRequestError(error);
					} finally {
						collectionsLoading.value = false;
					}
				};

				const loadIndexes = async () => {
					const collection = selectedCollection.value;
					if (!collection) return;
					const collectionName = collection.name;
					setCardLoadState('indexes', collectionName, 'loading');
					indexesLoading.value = true;
					const url = `/v1/collections/${encodeURIComponent(collectionName)}:listIndexes`;
					const entry = createActivityEntry({
						label: 'List indexes',
						method: 'POST',
						url,
						target: collectionName,
					});
					try {
						const resp = await http.post(url);
						markConnectionOnline();
						const list = Array.isArray(resp.data) ? resp.data : [];
						completeActivityEntry(entry, {
							detail: `Loaded ${list.length} indexes.`,
							statusCode: resp.status,
						});
						if (selectedCollection.value?.name === collectionName) {
							indexes.value = list;
							if (!list.some((idx) => idx.name === selectedIndexName.value)) {
								selectedIndexName.value = '';
							}
						}
						setCardLoadState('indexes', collectionName, 'loaded');
					} catch (error) {
						if (selectedCollection.value?.name === collectionName) {
							indexes.value = [];
						}
						setCardLoadState('indexes', collectionName, 'failed');
						failActivityEntry(entry, error, { fallback: 'Failed to load indexes.' });
						handleRequestError(error);
					} finally {
						indexesLoading.value = false;
					}
				};

				const refreshSizeMetrics = async () => {
					if (sizeMetrics.loading) return;
					const collection = selectedCollection.value;
					if (!collection) {
						resetSizeMetrics();
						return;
					}
					sizeMetrics.loading = true;
					sizeMetrics.error = '';
					const collectionName = collection.name;
					setCardLoadState('metrics', collectionName, 'loading');
					const url = `/v1/collections/${encodeURIComponent(collectionName)}:size`;
					const entry = createActivityEntry({
						label: 'Get collection size metrics',
						method: 'POST',
						url,
						target: collectionName,
					});
					try {
						const resp = await http.post(url);
						markConnectionOnline();
						const payload = resp?.data;
						const normalized = payload && typeof payload === 'object' && !Array.isArray(payload)
							? payload
							: {};
						if (selectedCollection.value?.name === collectionName) {
							sizeMetrics.data = normalized;
							sizeMetrics.updatedAt = new Date();
							sizeMetrics.error = '';
						}
						setCardLoadState('metrics', collectionName, 'loaded');
						completeActivityEntry(entry, {
							detail: 'Size metrics retrieved successfully.',
							statusCode: resp.status,
						});
					} catch (error) {
						if (selectedCollection.value?.name === collectionName) {
							sizeMetrics.error = error?.response?.data?.error || 'Failed to load size metrics.';
							sizeMetrics.data = null;
							sizeMetrics.updatedAt = null;
						}
						setCardLoadState('metrics', collectionName, 'failed');
						failActivityEntry(entry, error, { fallback: 'Failed to load size metrics.' });
						handleRequestError(error);
					} finally {
						if (selectedCollection.value?.name === collectionName) {
							sizeMetrics.loading = false;
						}
					}
				};

				const parseFilter = () => {
					const raw = filterText.value.trim();
					if (!raw) {
						filterText.value = '{}';
						return {};
					}
					try {
						const parsed = JSON.parse(raw);
						filterError.value = '';
						return parsed;
					} catch (err) {
						filterError.value = 'Invalid JSON: ' + err.message;
						return null;
					}
				};

				const buildQueryPayload = (overrides = {}) => {
					const parsedFilter = parseFilter();
					if (parsedFilter === null) {
						const error = new Error('invalid-filter');
						error.code = 'invalid-filter';
						throw error;
					}
					const payload = {
						filter: parsedFilter,
						limit: overrides.limit !== undefined ? Number(overrides.limit) : toNonNegativeInteger(limit.value, 0),
						skip: overrides.skip !== undefined ? Number(overrides.skip) : offset.value,
					};
					const index = activeIndex.value;
					if (index) {
						payload.index = index.name;
						if (index.type === 'map') {
							if (!mapValue.value) {
								const error = new Error('map-value-required');
								error.code = 'map-value-required';
								throw error;
							}
							payload.value = mapValue.value;
						} else if (index.type === 'btree') {
							payload.reverse = !!reverse.value;
							const fields = index.fields || [];
							if (fields.length && fields.every((field) => rangeFrom[field])) {
								const from = {};
								fields.forEach((field) => {
									from[field] = rangeFrom[field];
								});
								payload.from = from;
							}
							if (fields.length && fields.every((field) => rangeTo[field])) {
								const to = {};
								fields.forEach((field) => {
									to[field] = rangeTo[field];
								});
								payload.to = to;
							}
						} else if (index.type === 'fts') {
							if (!ftsMatch.value) {
								const error = new Error('fts-match-required');
								error.code = 'fts-match-required';
								throw error;
							}
							payload.match = ftsMatch.value;
						}
					}
					if (!Number.isFinite(payload.limit) || payload.limit < 0) {
						payload.limit = 0;
					}
					if (!Number.isFinite(payload.skip) || payload.skip < 0) {
						payload.skip = 0;
					}
					if (overrides.value !== undefined) {
						payload.value = overrides.value;
					}
					if (overrides.from !== undefined) {
						payload.from = overrides.from;
					}
					if (overrides.to !== undefined) {
						payload.to = overrides.to;
					}
					if (overrides.reverse !== undefined) {
						payload.reverse = overrides.reverse;
					}
					return payload;
				};

				const runQuery = async () => {
					if (!selectedCollection.value) return;
					queryError.value = '';
					let payload;
					try {
						payload = buildQueryPayload();
					} catch (error) {
						if (error.code === 'invalid-filter') {
							queryError.value = 'The filter must be valid JSON.';
						} else if (error.code === 'map-value-required') {
							queryError.value = 'You must provide a value for the selected index.';
						} else if (error.code === 'fts-match-required') {
							queryError.value = 'You must provide search terms for the selected index.';
						} else {
							queryError.value = error.message || 'Failed to prepare the query.';
						}
						return;
					}
					queryLoading.value = true;
					const started = performance.now();
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:find`;
					const entry = createActivityEntry({
						label: 'Query documents',
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: payload,
					});
					try {
						const resp = await http.request({
							method: 'post',
							url,
							data: payload,
							transformResponse: (res) => res,
							responseType: 'text',
						});
						const raw = resp.data || '';
						const lines = raw.split('\n').filter(Boolean);
						const parsedRows = lines.map((line) => {
							let parsed;
							try {
								parsed = JSON.parse(line);
							} catch (err) {
								parsed = { _raw: line };
							}
							attachRawLine(parsed, line);
							return parsed;
						});
						if (!exportState.running) {
							resetExportState();
						}
						queryRows.value = parsedRows;
						queryStats.returned = parsedRows.length;
						const elapsed = Math.round(performance.now() - started);
						queryStats.elapsed = `${elapsed} ms`;
						appliedSkip.value = offset.value;
						appliedLimit.value = toNonNegativeInteger(limit.value, 0);
						lastQueryParameters = {
							collection: selectedCollection.value.name,
							payload: JSON.parse(JSON.stringify(payload)),
						};
						syncRouteToCurrentState({
							collection: selectedCollection.value.name,
							skip: payload.skip,
							limit: payload.limit,
							query: filterText.value,
						});
						markConnectionOnline();
						completeActivityEntry(entry, {
							detail: `Retrieved ${parsedRows.length} documents in ${elapsed} ms.`,
							statusCode: resp.status,
						});
					} catch (error) {
						queryError.value = error?.response?.data?.error || 'Failed to fetch the collection.';
						failActivityEntry(entry, error, { fallback: 'Failed to fetch the collection.' });
						handleRequestError(error);
					} finally {
						queryLoading.value = false;
					}
				};

				const lookupDocument = async () => {
					quickSearch.error = '';
					quickSearch.result = null;
					if (!selectedCollection.value) {
						quickSearch.error = 'Select a collection before searching for a document.';
						return;
					}
					const id = (quickSearch.id || '').trim();
					if (!id) {
						quickSearch.error = 'Enter a document ID to search.';
						return;
					}
					quickSearch.loading = true;
					quickSearch.lastCheckedId = id;
					const collectionName = selectedCollection.value.name;
					const url = `/v1/collections/${encodeURIComponent(collectionName)}/documents/${encodeURIComponent(id)}`;
					const entry = createActivityEntry({
						label: 'Lookup document by ID',
						method: 'GET',
						url,
						target: collectionName,
					});
					const started = performance.now();
					try {
						const resp = await http.get(url);
						const data = resp?.data || {};
						const document = data.document && typeof data.document === 'object' ? data.document : {};
						quickSearch.result = {
							id: data.id || id,
							document,
							source: data.source || null,
						};
						quickSearch.error = '';
						const elapsed = Math.round(performance.now() - started);
						markConnectionOnline();
						completeActivityEntry(entry, {
							detail: `Retrieved document ${id} in ${elapsed} ms.`,
							statusCode: resp.status,
						});
					} catch (error) {
						quickSearch.result = null;
						const status = error?.response?.status;
						if (status === 404) {
							quickSearch.error = `No document with ID "${id}" was found.`;
						} else if (status === 400) {
							quickSearch.error = 'The provided document ID is not valid.';
						} else {
							quickSearch.error = error?.response?.data?.error || 'Failed to lookup the document.';
						}
						failActivityEntry(entry, error, { fallback: 'Failed to lookup the document.' });
						handleRequestError(error);
					} finally {
						quickSearch.loading = false;
					}
				};

				const applyQuickSearchResult = async () => {
					if (!quickSearch.result) return;
					const id = quickSearch.result.id || quickSearch.lastCheckedId;
					if (!id) return;
					filterError.value = '';
					filterText.value = JSON.stringify({ id }, null, 2);
					skip.value = 0;
					limit.value = 1;
					const source = quickSearch.result.source;
					if (source && source.type === 'index' && source.name) {
						selectedIndexName.value = source.name;
					} else {
						selectedIndexName.value = '';
					}
					await nextTick();
					await runQuery();
				};

				const exportResults = async () => {
					if (!selectedCollection.value) {
						exportState.error = 'Select a collection before exporting.';
						exportState.progress = '';
						return;
					}
					if (!Array.isArray(queryRows.value) || queryRows.value.length === 0) {
						exportState.error = 'No results to export. Run a query first.';
						exportState.progress = '';
						return;
					}
					if (exportState.running) return;
					exportState.error = '';
					exportState.progress = '';
					let exportAll = window.confirm('Export all matching documents? Click OK for all results, or Cancel to choose a different option.');
					if (!exportAll) {
						const exportPage = window.confirm('Export only the current page? Click OK to export the current page, or Cancel to abort.');
						if (!exportPage) {
							exportState.error = '';
							exportState.progress = '';
							return;
						}
					}
					const collectionName = selectedCollection.value.name;
					const filename = makeExportFilename(collectionName);
					exportState.running = true;

					if (!exportAll) {
						const entry = createActivityEntry({
							label: 'Export current page (JSONL)',
							method: 'EXPORT',
							url: 'local://export-page',
							target: collectionName,
						});
						try {
							const lines = queryRows.value
								.map((row) => toJsonlLine(row))
								.filter((line) => typeof line === 'string' && line.length > 0);
							if (!lines.length) {
								throw new Error('The current page does not contain exportable documents.');
							}
							const normalized = lines.map((line) => (line.endsWith('\n') ? line : `${line}\n`));
							downloadJsonl(normalized, filename);
							exportState.progress = `Exported ${lines.length} documents to ${filename}.`;
							completeActivityEntry(entry, { detail: exportState.progress, statusCode: 200 });
						} catch (error) {
							exportState.error = error?.message || 'Failed to export the current page.';
							failActivityEntry(entry, error, { fallback: 'Failed to export the current page.' });
						} finally {
							exportState.running = false;
						}
						return;
					}

					if (!lastQueryParameters || lastQueryParameters.collection !== collectionName) {
						exportState.error = 'Run the query before exporting all results.';
						exportState.running = false;
						return;
					}

					const url = `/v1/collections/${encodeURIComponent(collectionName)}:find`;
					const template = JSON.parse(JSON.stringify(lastQueryParameters.payload || {}));
					const entry = createActivityEntry({
						label: 'Export all results (JSONL)',
						method: 'POST',
						url,
						target: collectionName,
						requestBody: (() => {
							const initialPayload = JSON.parse(JSON.stringify(template));
							initialPayload.skip = 0;
							initialPayload.limit = EXPORT_BATCH_SIZE;
							return initialPayload;
						})(),
					});
					exportState.progress = 'Preparing export for all matching documentsâ€¦';

					try {
						const chunks = [];
						let totalExported = 0;
						let batches = 0;
						let lastStatusCode = null;
						while (batches < MAX_EXPORT_BATCHES) {
							const payload = JSON.parse(JSON.stringify(template));
							payload.skip = totalExported;
							payload.limit = EXPORT_BATCH_SIZE;
							const resp = await http.request({
								method: 'post',
								url,
								data: payload,
								transformResponse: (res) => res,
								responseType: 'text',
							});
							lastStatusCode = resp.status;
							const text = resp.data || '';
							if (text) {
								const normalizedText = text.endsWith('\n') ? text : `${text}\n`;
								chunks.push(normalizedText);
							}
							const exportedLines = text ? text.split('\n').filter(Boolean).length : 0;
							totalExported += exportedLines;
							batches += 1;
							exportState.progress = exportedLines
								? `Exported ${totalExported} documentsâ€¦`
								: 'No more documents to export.';
							entry.detail = exportState.progress;
							markConnectionOnline();
							if (exportedLines < EXPORT_BATCH_SIZE) {
								break;
							}
						}
						if (batches >= MAX_EXPORT_BATCHES) {
							throw new Error('Export stopped after reaching the maximum number of batches. Refine the query or request backend assistance for very large exports.');
						}
						if (!chunks.length) {
							throw new Error('The query did not return any documents to export.');
						}
						downloadJsonl(chunks, filename);
						exportState.progress = `Exported ${totalExported} documents to ${filename}.`;
						completeActivityEntry(entry, {
							detail: exportState.progress,
							statusCode: lastStatusCode ?? 200,
						});
					} catch (error) {
						exportState.error = error?.response?.data?.error || error?.message || 'Failed to export the results.';
						failActivityEntry(entry, error, { fallback: 'Failed to export the results.' });
						if (error?.isAxiosError || error?.response || error?.request) {
							handleRequestError(error);
						}
					} finally {
						exportState.running = false;
					}
				};

				const nextPage = () => {
					if (disableNext.value) return;
					const step = toNonNegativeInteger(limit.value, 0);
					if (step === 0) return;
					skip.value = offset.value + step;
					runQuery();
				};

				const prevPage = () => {
					if (disablePrev.value) return;
					const step = toNonNegativeInteger(limit.value, 0);
					if (step === 0) return;
					skip.value = Math.max(0, offset.value - step);
					runQuery();
				};

				const commitSkip = () => {
					const normalized = toNonNegativeInteger(skip.value, 0);
					const previous = appliedSkip.value;
					if (normalized !== skip.value) {
						skip.value = normalized;
					}
					if (normalized !== previous) {
						runQuery();
					}
				};

				const commitLimit = () => {
					const normalized = toNonNegativeInteger(limit.value, DEFAULT_LIMIT);
					const previous = appliedLimit.value;
					if (normalized !== limit.value) {
						limit.value = normalized;
					}
					if (normalized !== previous) {
						if (skip.value !== 0) {
							skip.value = 0;
						}
						runQuery();
					}
				};

				watch(selectedCollectionName, (name) => {
					clearEditingDocuments();
					defaultsHelpOpen.value = false;
					if (!restoringRoute) {
						skip.value = 0;
					}
					csvImportForm.error = '';
					csvImportForm.success = '';
					csvImportForm.progress = '';
					resetQuickSearchState(!name);
				});

				watch(queryRows, (rows) => {
					if (!Array.isArray(rows)) return;
					const activeIds = new Set();
					rows.forEach((row) => {
						const id = documentId(row);
						if (!id) return;
						activeIds.add(id);
						const state = editingDocuments[id];
						if (state && !state.open && !state.saving) {
							const snapshot = JSON.parse(JSON.stringify(row));
							const formatted = JSON.stringify(snapshot, null, 2);
							state.parsedOriginal = snapshot;
							state.original = formatted;
							state.draft = formatted;
							state.error = '';
							state.success = '';
						}
					});
					Object.keys(editingDocuments).forEach((key) => {
						if (!activeIds.has(key)) {
							delete editingDocuments[key];
						}
					});
				});

				watch(
					() => quickSearch.id,
					() => {
						if (quickSearch.error) {
							quickSearch.error = '';
						}
					},
				);

				const canDeleteRow = (row) => documentId(row) !== null;

				const deleteRow = async (row) => {
					if (!selectedCollection.value) return;
					const id = documentId(row);
					if (!id) {
						queryError.value = 'The document does not contain an "id" field.';
						return;
					}
					const ok = window.confirm(`Delete the document with id ${id}?`);
					if (!ok) return;
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:remove`;
					const requestPayload = {
						filter: { id: row.id },
						limit: 1,
					};
					const entry = createActivityEntry({
						label: `Delete document ${id}`,
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: requestPayload,
					});
					try {
						const resp = await http.post(url, requestPayload);
						markConnectionOnline();
						completeActivityEntry(entry, {
							detail: `Deleted document with id ${id}.`,
							statusCode: resp.status,
						});
						await runQuery();
						await loadCollections();
					} catch (error) {
						queryError.value = error?.response?.data?.error || 'Failed to delete the document.';
						failActivityEntry(entry, error, { fallback: 'Failed to delete the document.' });
						handleRequestError(error);
					}
				};

				const saveDefaults = async () => {
					defaultsForm.error = '';
					defaultsForm.success = '';
					if (!selectedCollection.value) {
						defaultsForm.error = 'Select a collection before editing defaults.';
						return;
					}
					let parsed;
					const raw = defaultsForm.draft.trim();
					if (!raw) {
						parsed = {};
					} else {
						try {
							parsed = JSON.parse(raw);
						} catch (err) {
							defaultsForm.error = 'Invalid JSON: ' + err.message;
							return;
						}
					}
					if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
						defaultsForm.error = 'Defaults must be a JSON object.';
						return;
					}
					defaultsForm.saving = true;
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:setDefaults`;
					const entry = createActivityEntry({
						label: 'Update defaults',
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: parsed,
					});
					try {
						const resp = await http.post(url, parsed);
						markConnectionOnline();
						const savedDefaults = normalizeDefaults(resp?.data ?? parsed);
						const formatted = formatDefaultsEditor(savedDefaults);
						defaultsForm.original = formatted;
						defaultsForm.draft = formatted;
						defaultsForm.success = 'Defaults updated successfully.';
						completeActivityEntry(entry, {
							detail: 'Defaults updated successfully.',
							statusCode: resp.status,
						});
						const target = collections.value.find((item) => item.name === selectedCollection.value.name);
						if (target) {
							target.defaults = normalizeDefaults(savedDefaults);
						}
					} catch (error) {
						defaultsForm.error = error?.response?.data?.error || 'Failed to update defaults.';
						failActivityEntry(entry, error, { fallback: 'Failed to update defaults.' });
						handleRequestError(error);
					} finally {
						defaultsForm.saving = false;
					}
				};

				const insertDocument = async () => {
					insertForm.error = '';
					insertForm.success = '';
					if (!selectedCollection.value) {
						insertForm.error = 'Select a collection before inserting.';
						return;
					}
					let payload;
					try {
						payload = JSON.parse(insertForm.payload);
					} catch (err) {
						insertForm.error = 'Invalid JSON: ' + err.message;
						return;
					}
					const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:insert`;
					const entry = createActivityEntry({
						label: 'Insert document',
						method: 'POST',
						url,
						target: selectedCollection.value.name,
						requestBody: payload,
					});
					try {
						const resp = await http.post(url, payload);
						insertForm.success = 'Document inserted successfully.';
						insertForm.payload = emptyJsonObjectText;
						markConnectionOnline();
						completeActivityEntry(entry, {
							detail: 'Document inserted successfully.',
							statusCode: resp.status,
						});
						await runQuery();
						await loadCollections();
					} catch (error) {
						insertForm.error = error?.response?.data?.error || 'Failed to insert the document.';
						failActivityEntry(entry, error, { fallback: 'Failed to insert the document.' });
						handleRequestError(error);
					}
				};

				const createCollection = async () => {
					createForm.error = '';
					const name = createForm.name.trim();
					if (!name) {
						createForm.error = 'Provide a name for the collection.';
						return;
					}
					const requestPayload = { name };
					const entry = createActivityEntry({
						label: `Create collection ${name}`,
						method: 'POST',
						url: '/v1/collections',
						target: name,
						requestBody: requestPayload,
					});
					try {
						const resp = await http.post('/v1/collections', requestPayload);
						markConnectionOnline();
						const created = resp?.data?.name || name;
						completeActivityEntry(entry, {
							detail: `Collection "${created}" created successfully.`,
							statusCode: resp.status,
						});
						await loadCollections();
						selectedCollectionName.value = created;
						createForm.name = '';
						createForm.open = false;
					} catch (error) {
						createForm.error = error?.response?.data?.error || 'Failed to create the collection.';
						failActivityEntry(entry, error, { fallback: 'Failed to create the collection.' });
						handleRequestError(error);
					}
				};

				const dropCollection = async () => {
					if (!selectedCollection.value) return;
					const name = selectedCollection.value.name;
					const ok = window.confirm(`Delete the collection "${name}"? This action cannot be undone.`);
					if (!ok) return;
					const url = `/v1/collections/${encodeURIComponent(name)}:dropCollection`;
					const entry = createActivityEntry({
						label: `Delete collection ${name}`,
						method: 'POST',
						url,
						target: name,
					});
					try {
						const resp = await http.post(url);
						markConnectionOnline();
						completeActivityEntry(entry, {
							detail: `Collection "${name}" deleted successfully.`,
							statusCode: resp.status,
						});
						selectedCollectionName.value = '';
						await loadCollections();
					} catch (error) {
						queryError.value = error?.response?.data?.error || 'Failed to delete the collection.';
						failActivityEntry(entry, error, { fallback: 'Failed to delete the collection.' });
						handleRequestError(error);
					}
				};

				const formatDocument = (row) => {
					if (row && typeof row === 'object' && '_raw' in row) {
						return row._raw;
					}
					try {
						return JSON.stringify(row, null, 2);
					} catch (err) {
						return String(row);
					}
				};

				const formatTableValue = (row, column) => {
					if (!row || typeof row !== 'object' || Array.isArray(row)) return '';
					if (!Object.prototype.hasOwnProperty.call(row, column)) return '';
					const value = row[column];
					if (value === undefined) return '';
					if (value === null) return 'null';
					if (typeof value === 'bigint') return value.toString();
					if (typeof value === 'object') {
						if (Object.prototype.hasOwnProperty.call(value, '_raw')) {
							return String(value._raw);
						}
						try {
							const text = JSON.stringify(value);
							return text.length > 160 ? `${text.slice(0, 157)}â€¦` : text;
						} catch (err) {
							return '[object]';
						}
					}
					const text = String(value);
					return text.length > 160 ? `${text.slice(0, 157)}â€¦` : text;
				};

				onMounted(() => {
					beginConnectionCheck();
					window.addEventListener('keydown', handleKeydown);
					window.addEventListener('hashchange', handleHashChange);
					const initialRoute = currentRouteState();
					if (
						initialRoute.collection ||
						initialRoute.query !== undefined ||
						initialRoute.skip !== undefined ||
						initialRoute.limit !== undefined
					) {
						applyRouteState(initialRoute);
					} else if (typeof window !== 'undefined' && !window.location.hash) {
						syncRouteToCurrentState();
					}
					loadCollections();
					statusPoller = window.setInterval(checkBackendStatus, 30000);
				});

				onBeforeUnmount(() => {
					if (statusPoller) {
						window.clearInterval(statusPoller);
						statusPoller = null;
					}
					window.removeEventListener('keydown', handleKeydown);
					window.removeEventListener('hashchange', handleHashChange);
				});

				return {
					// state
					collections,
					collectionsLoading,
					collectionsError,
					selectedCollection,
					selectedCollectionName,
					indexes,
					indexesLoading,
					filterText,
					filterError,
					queryRows,
					queryLoading,
					queryError,
					queryStats,
					resultsViewMode,
					selectedIndexName,
					activeIndex,
					mapValue,
					reverse,
					rangeFrom,
					rangeTo,
					editingDocuments,
					tableColumns,
					openEditingRows,
					indexForm,
					indexMessages,
					insertForm,
					csvImportForm,
					defaultsForm,
					defaultsHelpOpen,
					collapsibleCards,
					createForm,
					connectionStatus,
					activityLog,
					activityDetailOpen,
					selectedActivityEntry,
					exportState,
					sizeMetrics,
					quickSearch,
					quickSearchResultText,
					quickSearchSourceLabel,
					sizeMetricsEntries,
					sizeMetricsUpdatedLabel,
					connectionStatusLabel,
					connectionStatusDescription,
					connectionStatusBadgeClass,
					connectionStatusDotClass,
					connectionStatusButtonLabel,
					connectionStatusChecking,
					disablePrev,
					disableNext,
					skip,
					limit,
					offset,
					pageInfo,
					selectResultsView,
					// methods
					prettyTotal,
					isSelected,
					toggleCreateForm,
					toggleCard,
					toggleIndexForm,
					selectCollection,
					runQuery,
					lookupDocument,
					applyQuickSearchResult,
					exportResults,
					nextPage,
					prevPage,
					commitSkip,
					commitLimit,
					documentId,
					canEditDocument,
					isEditingRow,
					openEditRow,
					closeEditRow,
					saveEditRow,
					onEditDraftInput,
					createIndex,
					removeIndex,
					resetDefaultsForm,
					saveDefaults,
					insertDocument,
					onCsvFileChange,
					resetCsvImportForm,
					importCsv,
					createCollection,
					dropCollection,
					deleteRow,
					canDeleteRow,
					formatDocument,
					formatTableValue,
					refreshConnectionStatus,
					refreshSizeMetrics,
					formatActivityTime,
					formatDuration,
					activityStatusLabel,
					activityStatusBadgeClass,
					clearActivityLog,
					activityMarkerClass,
					activityMarkerTitle,
					activityRequestHeaders,
					activityRequestBody,
					activityRequestTabEntries,
					selectedActivityRequestTab,
					activeActivityRequestTabContent,
					buildCurlCommand,
					activityModal,
					modalMode,
					openActivityDetail,
					closeActivityDetail,
					closeActivityModal,
				};
			},
		}).mount('#app');
	</script>
	<script>
		(function () {
			var mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

			function applyTheme(isDark) {
				document.body.classList.toggle('theme-dark', isDark);
				document.body.classList.toggle('theme-light', !isDark);
			}

			applyTheme(mediaQuery.matches);

			if (typeof mediaQuery.addEventListener === 'function') {
				mediaQuery.addEventListener('change', function (event) {
					applyTheme(event.matches);
				});
			} else if (typeof mediaQuery.addListener === 'function') {
				mediaQuery.addListener(function (event) {
					applyTheme(event.matches);
				});
			}
		})();
	</script>
</body>

</html>